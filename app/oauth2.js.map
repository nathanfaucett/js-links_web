{"version":3,"sources":["oauth2.js","config.js","../../node_modules/@nathanfaucett/qs/src/index.js","../../node_modules/@nathanfaucett/url/src/index.js","../../node_modules/@nathanfaucett/request/src/browser.js","../../node_modules/buffer/index.js","../../node_modules/@nathanfaucett/index_of/src/index.js","../../node_modules/@nathanfaucett/has/src/index.js","../../node_modules/@nathanfaucett/keys/src/index.js","../../node_modules/@nathanfaucett/is_primitive/src/index.js","../../node_modules/@nathanfaucett/is_array_like/src/index.js","../../node_modules/@nathanfaucett/is_nan/src/index.js","../../node_modules/@nathanfaucett/is_object/src/index.js","../../node_modules/base64-js/lib/b64.js","../../node_modules/ieee754/index.js","../../node_modules/isarray/index.js","../../node_modules/@nathanfaucett/is_equal/src/index.js","../../node_modules/@nathanfaucett/is_native/src/index.js","../../node_modules/@nathanfaucett/get_prototype_of/src/index.js","../../node_modules/@nathanfaucett/is_null_or_undefined/src/index.js","../../node_modules/@nathanfaucett/is_function/src/index.js","../../node_modules/@nathanfaucett/escape_regexp/src/index.js","../../node_modules/@nathanfaucett/is_null/src/index.js","../../node_modules/@nathanfaucett/is_undefined/src/index.js","../../node_modules/@nathanfaucett/to_string/src/index.js","../../node_modules/@nathanfaucett/is_string/src/index.js","../../node_modules/@nathanfaucett/is_length/src/index.js","../../node_modules/@nathanfaucett/is_number/src/index.js","../../node_modules/@nathanfaucett/create/src/index.js","../../node_modules/punycode/punycode.js","../../node_modules/process/browser.js","../../node_modules/@nathanfaucett/request/src/create.js","../../node_modules/@nathanfaucett/request/src/requestBrowser.js","../../node_modules/@nathanfaucett/methods/src/browser.js","../../node_modules/@nathanfaucett/array-for_each/src/index.js","../../node_modules/@nathanfaucett/event_emitter/src/index.js","../../node_modules/@nathanfaucett/request/src/defaults.js","../../node_modules/@nathanfaucett/inherits/src/index.js","../../node_modules/@nathanfaucett/fast_slice/src/index.js","../../node_modules/@nathanfaucett/extend/src/index.js","../../node_modules/@nathanfaucett/mixin/src/index.js","../../node_modules/@nathanfaucett/inherits/node_modules/@nathanfaucett/define_property/src/index.js","../../node_modules/@nathanfaucett/extend/node_modules/@nathanfaucett/keys/src/index.js","../../node_modules/@nathanfaucett/extend/node_modules/@nathanfaucett/has/src/index.js","../../node_modules/@nathanfaucett/clamp/src/index.js","../../node_modules/@nathanfaucett/promise_polyfill/src/index.js","../../node_modules/@nathanfaucett/xmlhttprequest_polyfill/src/index.js","../../node_modules/@nathanfaucett/object-for_each/src/index.js","../../node_modules/@nathanfaucett/trim/src/index.js","../../node_modules/@nathanfaucett/request/src/Response.js","../../node_modules/@nathanfaucett/request/src/camelcaseHeader.js","../../node_modules/@nathanfaucett/request/src/parseContentType.js","../../node_modules/@nathanfaucett/is_array/src/index.js","../../node_modules/@nathanfaucett/apply/src/index.js","../../node_modules/@nathanfaucett/weak_map_polyfill/src/index.js","../../node_modules/@nathanfaucett/iterator/src/index.js","../../node_modules/@nathanfaucett/create_store/src/index.js","../../node_modules/@nathanfaucett/define_property/src/index.js","../../node_modules/@nathanfaucett/xmlhttprequest_polyfill/src/EventPolyfill.js","../../node_modules/@nathanfaucett/xmlhttprequest_polyfill/src/ProgressEventPolyfill.js","../../node_modules/@nathanfaucett/xmlhttprequest_polyfill/src/tryCallFunction.js","../../node_modules/@nathanfaucett/xmlhttprequest_polyfill/src/trySetValue.js","../../node_modules/@nathanfaucett/xmlhttprequest_polyfill/src/emitEvent.js","../../node_modules/@nathanfaucett/xmlhttprequest_polyfill/src/toUint8Array.js","../../node_modules/@nathanfaucett/xmlhttprequest_polyfill/src/createNativeXMLHttpRequest.js","../../node_modules/@nathanfaucett/environment/src/index.js","../../node_modules/@nathanfaucett/array-map/src/index.js","../../node_modules/@nathanfaucett/capitalize_string/src/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAAA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CChDA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;;CChBA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CC9TA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCvlCA;CACA;;;;CCDA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CC5gDA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CClBA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCvCA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCpCA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCVA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCXA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCNA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCVA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CC5HA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCpFA;CACA;CACA;CACA;CACA;CACA;;;;CCLA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCNA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CC5CA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCnCA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCtBA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCpBA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CClBA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCNA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCNA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CChBA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCNA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCZA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCNA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;;CCnCA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCrhBA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCpLA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCzCA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCtMA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CC7BA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCfA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CChdA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCzCA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CC9CA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCxBA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCpCA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CChCA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCtDA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCpCA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCvCA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;;CCZA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CC9UA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CC3LA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCtBA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CC1DA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCXA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCPA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CChBA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCxBA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCnDA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CC9CA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CChGA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CChHA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCtDA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CC7DA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CChBA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCRA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCRA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCZA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCrBA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;;;CC/CA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CChCA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;CACA;;;;CCfA;CACA;CACA;CACA;CACA;CACA;CACA","file":"oauth2.js","sourceRoot":"","sourcesContent":["var config = require(\"./config\"),\n    qs = require(\"@nathanfaucett/qs\"),\n    url = require(\"@nathanfaucett/url\"),\n    request = require(\"@nathanfaucett/request\");\n\n\nvar opener = window.opener,\n    fullUrl = url.parse(location + \"\"),\n    search = qs.parse(fullUrl.search.slice(1)),\n    code = search.code;\n\n\nfunction init(provider) {\n    request.get(config.baseUrl + \"/users/\"+ provider +\"/callback?\" + qs.stringify({\n        code: code\n    }), {\n        success: function(response) {\n            opener.postMessage(JSON.stringify({\n                type: \"success\",\n                user: response.data\n            }), config.appUrl);\n            window.close();\n        },\n        error: function(response) {\n            opener.postMessage(JSON.stringify({\n                type: \"error\",\n                error: response.data\n            }), config.appUrl);\n            window.close();\n        }\n    });\n}\n\n\nfunction onMessage(event) {\n    var data = JSON.parse(event.data);\n\n    switch (data.type) {\n        case \"provider\":\n            init(data.provider);\n            break;\n    }\n}\nwindow.addEventListener(\"message\", onMessage, false);\n\nopener.postMessage(JSON.stringify({\n    type: \"load\"\n}), config.appUrl);\n","module.exports = {\n    \"env\": \"development\",\n    \"flatLocaleMode\": true,\n    \"locales\": [\n        \"en\"\n    ],\n    \"oauth2\": [\n        \"google\",\n        \"github\"\n    ],\n    \"throwMissingTranslationError\": false,\n    \"html5Mode\": false,\n    \"appUrl\": \"http://localhost:4000\",\n    \"baseUrl\": \"http://192.168.1.23:3000\",\n    \"baseUrlWS\": \"ws://192.168.1.23:3000\"\n};\n","var indexOf = require(\"@nathanfaucett/index_of\"),\n    has = require(\"@nathanfaucett/has\"),\n    keys = require(\"@nathanfaucett/keys\"),\n    isPrimitive = require(\"@nathanfaucett/is_primitive\"),\n    isArrayLike = require(\"@nathanfaucett/is_array_like\"),\n    isNaNShim = require(\"@nathanfaucett/is_nan\"),\n    isObject = require(\"@nathanfaucett/is_object\");\n\n\nvar qs = module.exports,\n\n    ObjectPrototype = Object.prototype,\n\n    reDecode = /\\+/g,\n    reParseKeysParent = /^([^\\[\\]]*)/,\n    reParseKeysChild = /(\\[[^\\[\\]]*\\])/g,\n    reParseKeysReplacer = /\\[|\\]/g;\n\n\nfunction mergeArrays(a, b) {\n    var i = -1,\n        length = b.length - 1,\n        offset = a.length;\n\n    while (i++ < length) {\n        a[offset + i] = b[i];\n    }\n\n    return a;\n}\n\nfunction stringify(obj, prefix) {\n    var key, values, i, length;\n\n    obj = Buffer.isBuffer(obj) ? obj.toString() : obj instanceof Date ? obj.toISOString() : obj != null ? obj : \"\";\n\n    if (isPrimitive(obj)) {\n        return [encodeURIComponent(prefix) + \"=\" + encodeURIComponent(obj)];\n    }\n\n    values = [];\n\n    if (isArrayLike(obj)) {\n        i = -1;\n        length = obj.length - 1;\n\n        while (i++ < length) {\n            mergeArrays(values, stringify(obj[i], prefix + \"[\" + i + \"]\"));\n        }\n    } else {\n        for (key in obj) {\n            if (has(obj, key)) {\n                mergeArrays(values, stringify(obj[key], prefix + \"[\" + key + \"]\"));\n            }\n        }\n    }\n\n    return values;\n}\n\nqs.stringify = function(obj, options) {\n    var keys = [],\n        delimiter, key;\n\n    delimiter = options && typeof(options.delimiter) !== \"undefined\" ? options.delimiter : \"&\";\n\n    for (key in obj) {\n        if (has(obj, key)) {\n            mergeArrays(keys, stringify(obj[key], key));\n        }\n    }\n\n    return keys.join(delimiter);\n};\n\nfunction decode(str) {\n    var value, num;\n\n    try {\n        value = decodeURIComponent(str.replace(reDecode, \" \"));\n        num = +value;\n        return num !== num ? value : num;\n    } catch (e) {\n        return str;\n    }\n}\n\nfunction parseValues(str, options) {\n    var obj = {},\n        parts = str.split(options.delimiter, options.parameterLimit === Infinity ? undefined : options.parameterLimit),\n        i = -1,\n        il = parts.length - 1,\n        part, index, pos, key, val;\n\n    while (i++ < il) {\n        part = parts[i];\n        index = part.indexOf(\"]=\");\n        pos = index === -1 ? part.indexOf(\"=\") : index + 1;\n\n        if (pos === -1) {\n            obj[decode(part)] = \"\";\n        } else {\n            key = decode(part.slice(0, pos));\n            val = decode(part.slice(pos + 1));\n\n            obj[key] = has(obj, key) ? [obj[key], val] : val;\n        }\n    }\n\n    return obj;\n}\n\nfunction parseObject(chain, val, options) {\n    var root, obj, cleanRoot, index;\n\n    if (!chain.length) {\n        return val;\n    }\n\n    root = chain.shift();\n\n    if (root === \"[]\") {\n        obj = [parseObject(chain, val, options)];\n    } else {\n        cleanRoot = \"[\" === root[0] && \"]\" === root[root.length - 1] ? root.slice(1, root.length - 1) : root;\n        index = +cleanRoot;\n\n        if (!isNaNShim(index) && root !== cleanRoot && index <= options.arrayLimit) {\n            obj = [];\n            obj[index] = parseObject(chain, val, options);\n        } else {\n            obj = {};\n            obj[cleanRoot] = parseObject(chain, val, options);\n        }\n    }\n\n    return obj;\n}\n\nfunction parseKeys(key, val, options) {\n    var parent = reParseKeysParent,\n        child = reParseKeysChild,\n        segment, keys, i;\n\n    if (!key) {\n        return undefined;\n    }\n\n    segment = parent.exec(key);\n\n    if (has(ObjectPrototype, segment[1])) {\n        return undefined;\n    }\n\n    keys = [];\n    segment[1] && (keys[keys.length] = segment[1]);\n\n    i = 0;\n    while (null !== (segment = child.exec(key)) && i < options.depth) {\n        if (!has(ObjectPrototype, segment[1].replace(reParseKeysReplacer, \"\"))) {\n            keys[keys.length] = segment[1];\n        }\n        i++;\n    }\n\n    segment && (keys[keys.length] = \"[\" + key.slice(segment.index) + \"]\");\n\n    return parseObject(keys, val, options);\n}\n\nfunction compact(obj, refs) {\n    var lookup, compacted, i, length, objectKeys, key, value;\n\n    if (!isObject(obj)) {\n        return obj;\n    }\n\n    refs = refs || [];\n    lookup = indexOf(refs, obj);\n\n    if (lookup !== -1) {\n        return refs[lookup];\n    }\n\n    refs[refs.length] = obj;\n\n    if (isArrayLike(obj)) {\n        compacted = [];\n\n        i = -1;\n        length = obj.length - 1;\n\n        while (i++ < length) {\n            value = obj[i];\n\n            if (value != null) {\n                compacted[compacted.length] = value;\n            }\n        }\n\n        return compacted;\n    }\n\n    objectKeys = keys(obj);\n    i = -1;\n    length = objectKeys.length - 1;\n\n    while (i++ < length) {\n        key = objectKeys[i];\n        obj[key] = compact(obj[key], refs);\n    }\n\n    return obj;\n}\n\nfunction arrayToObject(array) {\n    var obj = {},\n        i = -1,\n        length = array.length - 1,\n        value;\n\n    while (i++ < length) {\n        value = array[i];\n\n        if (value != null) {\n            obj[i] = value;\n        }\n    }\n\n    return obj;\n}\n\nfunction merge(target, source) {\n    var objectKeys, i, il, k, kl, key, value;\n\n    if (!source) {\n        return target;\n    }\n\n    if (isArrayLike(source)) {\n        i = -1;\n        il = source.length - 1;\n\n        while (i++ < il) {\n            key = target[i];\n            value = source[i];\n\n            if (value != null) {\n                if (isObject(key)) {\n                    target[i] = merge(key, value);\n                } else {\n                    target[i] = value;\n                }\n            }\n        }\n\n        return target;\n    }\n\n    if (isArrayLike(target)) {\n        if (typeof(source) !== \"object\") {\n            target[target.length] = source;\n            return target;\n        } else {\n            target = arrayToObject(target);\n        }\n    }\n\n    objectKeys = keys(source);\n    k = -1;\n    kl = objectKeys.length - 1;\n\n    while (k++ < kl) {\n        key = objectKeys[k];\n        value = source[key];\n\n        if (value && typeof(value) === \"object\") {\n            if (target[key] == null) {\n                target[key] = value;\n            } else {\n                target[key] = merge(target[key], value);\n            }\n        } else {\n            target[key] = value;\n        }\n    }\n\n    return target;\n}\n\nqs.parse = function(str, options) {\n    var obj = {},\n        tempObj, objectKeys, i, il, key, newObj;\n\n    if (str === \"\" || str == null) {\n        return obj;\n    }\n\n    options || (options = {});\n    options.delimiter = typeof(options.delimiter) === \"string\" || (options.delimiter instanceof RegExp) ? options.delimiter : \"&\";\n    options.depth = typeof(options.depth) === \"number\" ? options.depth : 5;\n    options.arrayLimit = typeof(options.arrayLimit) === \"number\" ? options.arrayLimit : 20;\n    options.parameterLimit = typeof(options.parameterLimit) === \"number\" ? options.parameterLimit : 1e3;\n\n    tempObj = typeof(str) === \"string\" ? parseValues(str, options) : str;\n\n    objectKeys = keys(tempObj);\n    i = -1;\n    il = objectKeys.length - 1;\n\n    while (i++ < il) {\n        key = objectKeys[i];\n        newObj = parseKeys(key, tempObj[key], options);\n        obj = merge(obj, newObj);\n    }\n\n    return compact(obj);\n};\n","var isObject = require(\"@nathanfaucett/is_object\"),\n    isString = require(\"@nathanfaucett/is_string\"),\n    isUndefined = require(\"@nathanfaucett/is_undefined\"),\n    isNull = require(\"@nathanfaucett/is_null\"),\n    create = require(\"@nathanfaucett/create\"),\n    keys = require(\"@nathanfaucett/keys\"),\n    punycode = require(\"punycode\"),\n    qs = require(\"@nathanfaucett/qs\");\n\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar url = exports,\n    toASCII = punycode.toASCII,\n\n    protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    hostnameMaxLen = 255,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n        'javascript': true,\n        'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n        'javascript': true,\n        'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n        'http': true,\n        'http:': true,\n        'https': true,\n        'https:': true,\n        'ftp': true,\n        'ftp:': true,\n        'gopher': true,\n        'gopher:': true,\n        'file': true,\n        'file:': true\n    };\n\n\nurl.parse = urlParse;\nurl.resolve = urlResolve;\nurl.resolveObject = urlResolveObject;\nurl.format = urlFormat;\n\nurl.Url = Url;\n\n\nfunction Url() {\n    this.protocol = null;\n    this.slashes = null;\n    this.auth = null;\n    this.host = null;\n    this.port = null;\n    this.hostname = null;\n    this.hash = null;\n    this.search = null;\n    this.query = null;\n    this.pathname = null;\n    this.path = null;\n    this.href = null;\n}\n\n\n\n// This constructor is used to store parsed query string values. Instantiating\n// this is faster than explicitly calling `Object.create(null)` to get a\n// \"clean\" empty object (tested with v8 v4.9).\nfunction ParsedQueryString() {}\nParsedQueryString.prototype = create(null);\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n    var u;\n\n    if (url instanceof Url) {\n        return url;\n    } else {\n        u = new Url();\n        u.parse(url, parseQueryString, slashesDenoteHost);\n        return u;\n    }\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n    if (!isString(url)) {\n        throw new TypeError('Parameter \"url\" must be a string, not ' + typeof url);\n    }\n    // Copy chrome, IE, opera backslash-handling behavior.\n    // Back slashes before the query string get converted to forward slashes\n    // See: https://code.google.com/p/chromium/issues/detail?id=25916\n    var hasHash = false,\n        start = -1,\n        end = -1,\n        rest = '',\n        lastPos = 0,\n        i = 0,\n        inWs, code, simplePath, proto, lowerProto, slashes, hostEnd, atSign,\n        nonHost, hostname, ipv6Hostname, result, p, h, questionIdx, hashIdx,\n        firstIdx, s;\n\n    for (inWs = false, split = false; i < url.length; ++i) {\n        code = url.charCodeAt(i);\n\n        // Find first and last non-whitespace characters for trimming\n        isWs = code === 32 /* */ ||\n            code === 9 /*\\t*/ ||\n            code === 13 /*\\r*/ ||\n            code === 10 /*\\n*/ ||\n            code === 12 /*\\f*/ ||\n            code === 160 /*\\u00A0*/ ||\n            code === 65279 /*\\uFEFF*/ ;\n\n        if (start === -1) {\n            if (isWs) {\n                continue;\n            }\n            lastPos = start = i;\n        } else {\n            if (inWs) {\n                if (!isWs) {\n                    end = -1;\n                    inWs = false;\n                }\n            } else if (isWs) {\n                end = i;\n                inWs = true;\n            }\n        }\n\n        // Only convert backslashes while we haven't seen a split character\n        if (!split) {\n            switch (code) {\n                case 35: // '#'\n                    hasHash = true;\n                    /* falls through */\n                case 63: // '?'\n                    split = true;\n                    break;\n                case 92: // '\\\\'\n                    if (i - lastPos > 0) {\n                        rest += url.slice(lastPos, i);\n                    }\n                    rest += '/';\n                    lastPos = i + 1;\n                    break;\n            }\n        } else if (!hasHash && code === 35 /*#*/ ) {\n            hasHash = true;\n        }\n    }\n\n    // Check if string was non-empty (including strings with only whitespace)\n    if (start !== -1) {\n        if (lastPos === start) {\n            // We didn't convert any backslashes\n\n            if (end === -1) {\n                if (start === 0) {\n                    rest = url;\n                } else {\n                    rest = url.slice(start);\n                }\n            } else {\n                rest = url.slice(start, end);\n            }\n        } else if (end === -1 && lastPos < url.length) {\n            // We converted some backslashes and have only part of the entire string\n            rest += url.slice(lastPos);\n        } else if (end !== -1 && lastPos < end) {\n            // We converted some backslashes and have only part of the entire string\n            rest += url.slice(lastPos, end);\n        }\n    }\n\n    if (!slashesDenoteHost && !hasHash) {\n        // Try fast path regexp\n        simplePath = simplePathPattern.exec(rest);\n\n        if (simplePath) {\n            this.path = rest;\n            this.href = rest;\n            this.pathname = simplePath[1];\n            if (simplePath[2]) {\n                this.search = simplePath[2];\n                if (parseQueryString) {\n                    this.query = qs.parse(this.search.slice(1));\n                } else {\n                    this.query = this.search.slice(1);\n                }\n            } else if (parseQueryString) {\n                this.search = '';\n                this.query = new ParsedQueryString();\n            }\n            return this;\n        }\n    }\n\n    proto = protocolPattern.exec(rest);\n    if (proto) {\n        proto = proto[0];\n        lowerProto = proto.toLowerCase();\n        this.protocol = lowerProto;\n        rest = rest.slice(proto.length);\n    }\n\n    // figure out if it's got a host\n    // user@server is *always* interpreted as a hostname, and url\n    // resolution will treat //foo/bar as host=foo,path=bar because that's\n    // how the browser resolves relative URLs.\n    if (slashesDenoteHost || proto || /^\\/\\/[^@\\/]+@[^@\\/]+/.test(rest)) {\n        slashes = rest.charCodeAt(0) === 47 && rest.charCodeAt(1) === 47;\n        if (slashes && !(proto && hostlessProtocol[proto])) {\n            rest = rest.slice(2);\n            this.slashes = true;\n        }\n    }\n\n    if (!hostlessProtocol[proto] &&\n        (slashes || (proto && !slashedProtocol[proto]))) {\n\n        // there's a hostname.\n        // the first instance of /, ?, ;, or # ends the host.\n        //\n        // If there is an @ in the hostname, then non-host chars *are* allowed\n        // to the left of the last @ sign, unless some host-ending character\n        // comes *before* the @-sign.\n        // URLs are obnoxious.\n        //\n        // ex:\n        // http://a@b@c/ => user:a@b host:c\n        // http://a@b?@c => user:a host:b path:/?@c\n\n        // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n        // Review our test case against browsers more comprehensively.\n\n        hostEnd = -1;\n        atSign = -1;\n        nonHost = -1;\n        for (i = 0; i < rest.length; i++) {\n            switch (rest.charCodeAt(i)) {\n                case 9: // '\\t'\n                case 10: // '\\n'\n                case 13: // '\\r'\n                case 32: // ' '\n                case 34: // '\"'\n                case 37: // '%'\n                case 39: // '\\''\n                case 59: // ';'\n                case 60: // '<'\n                case 62: // '>'\n                case 92: // '\\\\'\n                case 94: // '^'\n                case 96: // '`'\n                case 123: // '{'\n                case 124: // '|'\n                case 125: // '}'\n                    // Characters that are never ever allowed in a hostname from RFC 2396\n                    if (nonHost === -1) {\n                        nonHost = i;\n                    }\n                    break;\n                case 35: // '#'\n                case 47: // '/'\n                case 63: // '?'\n                    // Find the first instance of any host-ending characters\n                    if (nonHost === -1) {\n                        nonHost = i;\n                    }\n                    hostEnd = i;\n                    break;\n                case 64: // '@'\n                    // At this point, either we have an explicit point where the\n                    // auth portion cannot go past, or the last @ char is the decider.\n                    atSign = i;\n                    nonHost = -1;\n                    break;\n            }\n            if (hostEnd !== -1) {\n                break;\n            }\n        }\n        start = 0;\n        if (atSign !== -1) {\n            this.auth = decodeURIComponent(rest.slice(0, atSign));\n            start = atSign + 1;\n        }\n        if (nonHost === -1) {\n            this.host = rest.slice(start);\n            rest = '';\n        } else {\n            this.host = rest.slice(start, nonHost);\n            rest = rest.slice(nonHost);\n        }\n\n        // pull out port.\n        this.parseHost();\n\n        // we've indicated that there is a hostname,\n        // so even if it's empty, it has to be present.\n        if (!isString(this.hostname)) {\n            this.hostname = '';\n        }\n\n        hostname = this.hostname;\n\n        // if hostname begins with [ and ends with ]\n        // assume that it's an IPv6 address.\n        ipv6Hostname = hostname.charCodeAt(0) === 91 && hostname.charCodeAt(hostname.length - 1) === 93;\n\n        // validate a little.\n        if (!ipv6Hostname) {\n            result = validateHostname(this, rest, hostname);\n            if (!isUndefined(result)) {\n                rest = result;\n            }\n        }\n\n        if (this.hostname.length > hostnameMaxLen) {\n            this.hostname = '';\n        } else {\n            // hostnames are always lower case.\n            this.hostname = this.hostname.toLowerCase();\n        }\n\n        if (!ipv6Hostname) {\n            // IDNA Support: Returns a punycoded representation of \"domain\".\n            // It only converts parts of the domain name that\n            // have non-ASCII characters, i.e. it doesn't matter if\n            // you call it with a domain that already is ASCII-only.\n            this.hostname = toASCII(this.hostname);\n        }\n\n        p = this.port ? ':' + this.port : '';\n        h = this.hostname || '';\n        this.host = h + p;\n\n        // strip [ and ] from the hostname\n        // the host field still retains them, though\n        if (ipv6Hostname) {\n            this.hostname = this.hostname.slice(1, -1);\n            if (rest[0] !== '/') {\n                rest = '/' + rest;\n            }\n        }\n    }\n\n    // now rest is set to the post-host stuff.\n    // chop off any delim chars.\n    if (!unsafeProtocol[lowerProto]) {\n        // First, make 100% sure that any \"autoEscape\" chars get\n        // escaped, even if encodeURIComponent doesn't think they\n        // need to be.\n        result = autoEscapeStr(rest);\n        if (!isUndefined(result)) {\n            rest = result;\n        }\n    }\n\n    questionIdx = -1;\n    hashIdx = -1;\n    for (i = 0; i < rest.length; ++i) {\n        code = rest.charCodeAt(i);\n        if (code === 35 /*#*/ ) {\n            this.hash = rest.slice(i);\n            hashIdx = i;\n            break;\n        } else if (code === 63 /*?*/ && questionIdx === -1) {\n            questionIdx = i;\n        }\n    }\n\n    if (questionIdx !== -1) {\n        if (hashIdx === -1) {\n            this.search = rest.slice(questionIdx);\n            this.query = rest.slice(questionIdx + 1);\n        } else {\n            this.search = rest.slice(questionIdx, hashIdx);\n            this.query = rest.slice(questionIdx + 1, hashIdx);\n        }\n        if (parseQueryString) {\n            this.query = qs.parse(this.query);\n        }\n    } else if (parseQueryString) {\n        // no query string, but parseQueryString still requested\n        this.search = '';\n        this.query = new ParsedQueryString();\n    }\n\n    firstIdx = (\n        questionIdx !== -1 && (hashIdx === -1 || questionIdx < hashIdx) ?\n        questionIdx :\n        hashIdx\n    );\n\n    if (firstIdx === -1) {\n        if (rest.length > 0) {\n            this.pathname = rest;\n        }\n    } else if (firstIdx > 0) {\n        this.pathname = rest.slice(0, firstIdx);\n    }\n    if (slashedProtocol[lowerProto] &&\n        this.hostname && !this.pathname) {\n        this.pathname = '/';\n    }\n\n    // to support http.request\n    if (this.pathname || this.search) {\n        p = this.pathname || '';\n        s = this.search || '';\n        this.path = p + s;\n    }\n\n    // finally, reconstruct the href based on what has been validated.\n    this.href = this.format();\n\n    return this;\n};\n\nfunction validateHostname(self, rest, hostname) {\n    var i, lastPos, code;\n\n    for (i = 0, lastPos; i <= hostname.length; ++i) {\n        if (i < hostname.length) {\n            code = hostname.charCodeAt(i);\n        }\n        if (code === 46 /*.*/ || i === hostname.length) {\n            if (i - lastPos > 0) {\n                if (i - lastPos > 63) {\n                    self.hostname = hostname.slice(0, lastPos + 63);\n                    return '/' + hostname.slice(lastPos + 63) + rest;\n                }\n            }\n            lastPos = i + 1;\n            continue;\n        } else if ((code >= 48 /*0*/ && code <= 57 /*9*/ ) ||\n            (code >= 97 /*a*/ && code <= 122 /*z*/ ) ||\n            code === 45 /*-*/ ||\n            (code >= 65 /*A*/ && code <= 90 /*Z*/ ) ||\n            code === 43 /*+*/ ||\n            code === 95 /*_*/ ||\n            code > 127) {\n            continue;\n        }\n        // Invalid host character\n        self.hostname = hostname.slice(0, i);\n        if (i < hostname.length) {\n            return '/' + hostname.slice(i) + rest;\n        }\n        break;\n    }\n}\n\nfunction autoEscapeStr(rest) {\n    var newRest = '',\n        lastPos = 0,\n        i;\n    for (i = 0; i < rest.length; i++) {\n        // Automatically escape all delimiters and unwise characters from RFC 2396\n        // Also escape single quotes in case of an XSS attack\n        switch (rest.charCodeAt(i)) {\n            case 9: // '\\t'\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%09';\n                lastPos = i + 1;\n                break;\n            case 10: // '\\n'\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%0A';\n                lastPos = i + 1;\n                break;\n            case 13: // '\\r'\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%0D';\n                lastPos = i + 1;\n                break;\n            case 32: // ' '\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%20';\n                lastPos = i + 1;\n                break;\n            case 34: // '\"'\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%22';\n                lastPos = i + 1;\n                break;\n            case 39: // '\\''\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%27';\n                lastPos = i + 1;\n                break;\n            case 60: // '<'\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%3C';\n                lastPos = i + 1;\n                break;\n            case 62: // '>'\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%3E';\n                lastPos = i + 1;\n                break;\n            case 92: // '\\\\'\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%5C';\n                lastPos = i + 1;\n                break;\n            case 94: // '^'\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%5E';\n                lastPos = i + 1;\n                break;\n            case 96: // '`'\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%60';\n                lastPos = i + 1;\n                break;\n            case 123: // '{'\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%7B';\n                lastPos = i + 1;\n                break;\n            case 124: // '|'\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%7C';\n                lastPos = i + 1;\n                break;\n            case 125: // '}'\n                if (i - lastPos > 0) {\n                    newRest += rest.slice(lastPos, i);\n                }\n                newRest += '%7D';\n                lastPos = i + 1;\n                break;\n        }\n    }\n    if (lastPos === 0) {\n        return;\n    }\n    if (lastPos < rest.length) {\n        return newRest + rest.slice(lastPos);\n    } else {\n        return newRest;\n    }\n}\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n    // ensure it's an object, and not a string url.\n    // If it's an obj, this is a no-op.\n    // this way, you can call url_format() on strings\n    // to clean up potentially wonky urls.\n    if (isString(obj)) {\n        obj = urlParse(obj);\n    } else if (!isObject(obj) || isNull(obj)) {\n        throw new TypeError('Parameter \"urlObj\" must be an object, not ' +\n            isNull(obj) ? 'null' : typeof obj);\n    } else if (!(obj instanceof Url)) {\n        return Url.prototype.format.call(obj);\n    } else {\n        return obj.format();\n    }\n}\n\nUrl.prototype.format = function() {\n    var auth = this.auth || '',\n        protocol, pathname, hash, host, query, search, newPathname, lastPos, i;\n\n    if (auth) {\n        auth = encodeAuth(auth);\n        auth += '@';\n    }\n\n    protocol = this.protocol || '';\n    pathname = this.pathname || '';\n    hash = this.hash || '';\n    host = '';\n    query = '';\n\n    if (this.host) {\n        host = auth + this.host;\n    } else if (this.hostname) {\n        host = (\n            auth + (this.hostname.indexOf(':') === -1 ?\n                this.hostname :\n                '[' + this.hostname + ']')\n        );\n        if (this.port) {\n            host += ':' + this.port;\n        }\n    }\n\n    if (isNull(this.query) && isObject(this.query)) {\n        query = qs.stringify(this.query);\n    }\n\n    search = this.search || (query && ('?' + query)) || '';\n\n    if (protocol && protocol.charCodeAt(protocol.length - 1) !== 58 /*:*/ ) {\n        protocol += ':';\n    }\n\n    newPathname = '';\n    lastPos = 0;\n    for (i = 0; i < pathname.length; ++i) {\n        switch (pathname.charCodeAt(i)) {\n            case 35: // '#'\n                if (i - lastPos > 0) {\n                    newPathname += pathname.slice(lastPos, i);\n                }\n                newPathname += '%23';\n                lastPos = i + 1;\n                break;\n            case 63: // '?'\n                if (i - lastPos > 0) {\n                    newPathname += pathname.slice(lastPos, i);\n                }\n                newPathname += '%3F';\n                lastPos = i + 1;\n                break;\n        }\n    }\n    if (lastPos > 0) {\n        if (lastPos !== pathname.length) {\n            pathname = newPathname + pathname.slice(lastPos);\n        } else {\n            pathname = newPathname;\n        }\n    }\n\n    // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n    // unless they had them to begin with.\n    if (this.slashes || slashedProtocol[protocol]) {\n        if (this.slashes || host) {\n            if (pathname && pathname.charCodeAt(0) !== 47 /*/*/ ) {\n                pathname = '/' + pathname;\n            }\n            host = '//' + host;\n        } else if (protocol.length >= 4 &&\n            protocol.charCodeAt(0) === 102 /*f*/ &&\n            protocol.charCodeAt(1) === 105 /*i*/ &&\n            protocol.charCodeAt(2) === 108 /*l*/ &&\n            protocol.charCodeAt(3) === 101 /*e*/ ) {\n            host = '//';\n        }\n    }\n\n    search = search.replace(/#/g, '%23');\n\n    if (hash && hash.charCodeAt(0) !== 35 /*#*/ ) {\n        hash = '#' + hash;\n    }\n    if (search && search.charCodeAt(0) !== 63 /*?*/ ) {\n        search = '?' + search;\n    }\n\n    return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n    return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n    return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n    if (!source) {\n        return relative;\n    }\n    return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n    var rel, result, tkeys, tk, tkey, rkeys, rk, ks, v, k, relPath, p, s,\n        isSourceAbs, isRelAbs, mustEndAbs, removeAllDots, srcPath, psychotic,\n        authInHost, last, hasTrailingSlash, up, i, isAbsolute;\n\n    if (isString(relative)) {\n        rel = new Url();\n        rel.parse(relative, false, true);\n        relative = rel;\n    }\n\n    result = new Url();\n    tkeys = keys(this);\n    for (tk = 0; tk < tkeys.length; tk++) {\n        tkey = tkeys[tk];\n        result[tkey] = this[tkey];\n    }\n\n    // hash is always overridden, no matter what.\n    // even href=\"\" will remove it.\n    result.hash = relative.hash;\n\n    // if the relative url is empty, then there's nothing left to do here.\n    if (relative.href === '') {\n        result.href = result.format();\n        return result;\n    }\n\n    // hrefs like //foo/bar always cut to the protocol.\n    if (relative.slashes && !relative.protocol) {\n        // take everything except the protocol from relative\n        rkeys = keys(relative);\n\n        for (rk = 0; rk < rkeys.length; rk++) {\n            rkey = rkeys[rk];\n            if (rkey !== 'protocol') {\n                result[rkey] = relative[rkey];\n            }\n        }\n\n        //urlParse appends trailing / to urls like http://www.example.com\n        if (slashedProtocol[result.protocol] &&\n            result.hostname && !result.pathname) {\n            result.path = result.pathname = '/';\n        }\n\n        result.href = result.format();\n\n        return result;\n    }\n\n    if (relative.protocol && relative.protocol !== result.protocol) {\n        // if it's a known url protocol, then changing\n        // the protocol does weird things\n        // first, if it's not file:, then we MUST have a host,\n        // and if there was a path\n        // to begin with, then we MUST have a path.\n        // if it is file:, then the host is dropped,\n        // because that's known to be hostless.\n        // anything else is assumed to be absolute.\n        if (!slashedProtocol[relative.protocol]) {\n            ks = keys(relative);\n            for (v = 0; v < ks.length; v++) {\n                k = ks[v];\n                result[k] = relative[k];\n            }\n            result.href = result.format();\n            return result;\n        }\n\n        result.protocol = relative.protocol;\n        if (!relative.host &&\n            !/^file:?$/.test(relative.protocol) &&\n            !hostlessProtocol[relative.protocol]) {\n            relPath = (relative.pathname || '').split('/');\n            while (relPath.length && !(relative.host = relPath.shift())) {}\n            if (!relative.host) {\n                relative.host = '';\n            }\n            if (!relative.hostname) {\n                relative.hostname = '';\n            }\n            if (relPath[0] !== '') {\n                relPath.unshift('');\n            }\n            if (relPath.length < 2) {\n                relPath.unshift('');\n            }\n            result.pathname = relPath.join('/');\n        } else {\n            result.pathname = relative.pathname;\n        }\n        result.search = relative.search;\n        result.query = relative.query;\n        result.host = relative.host || '';\n        result.auth = relative.auth;\n        result.hostname = relative.hostname || relative.host;\n        result.port = relative.port;\n        // to support http.request\n        if (result.pathname || result.search) {\n            p = result.pathname || '';\n            s = result.search || '';\n            result.path = p + s;\n        }\n        result.slashes = result.slashes || relative.slashes;\n        result.href = result.format();\n        return result;\n    }\n\n    isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/');\n    isRelAbs = (\n        relative.host ||\n        relative.pathname && relative.pathname.charAt(0) === '/'\n    );\n    mustEndAbs = (isRelAbs || isSourceAbs || (result.host && relative.pathname));\n    removeAllDots = mustEndAbs;\n    srcPath = result.pathname && result.pathname.split('/') || [];\n    relPath = relative.pathname && relative.pathname.split('/') || [];\n    psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n    // if the url is a non-slashed url, then relative\n    // links like ../.. should be able\n    // to crawl up to the hostname, as well.  This is strange.\n    // result.protocol has already been set by now.\n    // Later on, put the first path part into the host field.\n    if (psychotic) {\n        result.hostname = '';\n        result.port = null;\n        if (result.host) {\n            if (srcPath[0] === '') {\n                srcPath[0] = result.host;\n            } else {\n                srcPath.unshift(result.host);\n            }\n        }\n        result.host = '';\n        if (relative.protocol) {\n            relative.hostname = null;\n            relative.port = null;\n            result.auth = null;\n            if (relative.host) {\n                if (relPath[0] === '') {\n                    relPath[0] = relative.host;\n                } else {\n                    relPath.unshift(relative.host);\n                }\n            }\n            relative.host = null;\n        }\n        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n    }\n\n    if (isRelAbs) {\n        // it's absolute.\n        if (relative.host || relative.host === '') {\n            if (result.host !== relative.host) {\n                result.auth = null;\n            }\n            result.host = relative.host;\n            result.port = relative.port;\n        }\n        if (relative.hostname || relative.hostname === '') {\n            if (result.hostname !== relative.hostname) {\n                result.auth = null;\n            }\n            result.hostname = relative.hostname;\n        }\n        result.search = relative.search;\n        result.query = relative.query;\n        srcPath = relPath;\n        // fall through to the dot-handling below.\n    } else if (relPath.length) {\n        // it's relative\n        // throw away the existing file, and take the new path instead.\n        if (!srcPath) {\n            srcPath = [];\n        }\n        srcPath.pop();\n        srcPath = srcPath.concat(relPath);\n        result.search = relative.search;\n        result.query = relative.query;\n    } else if (isNull(relative.search) && relative.search !== undefined) {\n        // just pull out the search.\n        // like href='?foo'.\n        // Put this after the other two cases because it simplifies the booleans\n        if (psychotic) {\n            result.hostname = result.host = srcPath.shift();\n            //occasionally the auth can get stuck only in host\n            //this especially happens in cases like\n            //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n            authInHost = result.host && result.host.indexOf('@') > 0 ?\n                result.host.split('@') : false;\n            if (authInHost) {\n                result.auth = authInHost.shift();\n                result.host = result.hostname = authInHost.shift();\n            }\n        }\n        result.search = relative.search;\n        result.query = relative.query;\n        //to support http.request\n        if (isNull(result.pathname) || isNull(result.search)) {\n            result.path = (result.pathname ? result.pathname : '') +\n                (result.search ? result.search : '');\n        }\n        result.href = result.format();\n        return result;\n    }\n\n    if (!srcPath.length) {\n        // no path at all.  easy.\n        // we've already handled the other stuff above.\n        result.pathname = null;\n        //to support http.request\n        if (result.search) {\n            result.path = '/' + result.search;\n        } else {\n            result.path = null;\n        }\n        result.href = result.format();\n\n        return result;\n    }\n\n    // if a url ENDs in . or .., then it must get a trailing slash.\n    // however, if it ends in anything else non-slashy,\n    // then it must NOT get a trailing slash.\n    last = srcPath.slice(-1)[0];\n    hasTrailingSlash = (\n        (result.host || relative.host || srcPath.length > 1) &&\n        (last === '.' || last === '..') || last === '');\n\n    // strip single dots, resolve double dots to parent dir\n    // if the path tries to go above the root, `up` ends up > 0\n    up = 0;\n    for (i = srcPath.length - 1; i >= 0; i--) {\n        last = srcPath[i];\n        if (last === '.') {\n            spliceOne(srcPath, i);\n        } else if (last === '..') {\n            spliceOne(srcPath, i);\n            up++;\n        } else if (up) {\n            spliceOne(srcPath, i);\n            up--;\n        }\n    }\n\n    // if the path is allowed to go above the root, restore leading ..s\n    if (!mustEndAbs && !removeAllDots) {\n        for (; up--; up) {\n            srcPath.unshift('..');\n        }\n    }\n\n    if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n        srcPath.unshift('');\n    }\n\n    if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n        srcPath.push('');\n    }\n\n    isAbsolute = srcPath[0] === '' || (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n    // put the host back\n    if (psychotic) {\n        result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';\n        //occasionally the auth can get stuck only in host\n        //this especially happens in cases like\n        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n        authInHost = result.host && result.host.indexOf('@') > 0 ?\n            result.host.split('@') : false;\n        if (authInHost) {\n            result.auth = authInHost.shift();\n            result.host = result.hostname = authInHost.shift();\n        }\n    }\n\n    mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n    if (mustEndAbs && !isAbsolute) {\n        srcPath.unshift('');\n    }\n\n    if (!srcPath.length) {\n        result.pathname = null;\n        result.path = null;\n    } else {\n        result.pathname = srcPath.join('/');\n    }\n\n    //to support request.http\n    if (isNull(result.pathname) || isNull(result.search)) {\n        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');\n    }\n    result.auth = relative.auth || result.auth;\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n\n    return result;\n};\n\nUrl.prototype.parseHost = function() {\n    var host = this.host,\n        port = portPattern.exec(host);\n\n    if (port) {\n        port = port[0];\n        if (port !== ':') {\n            this.port = port.slice(1);\n        }\n        host = host.slice(0, host.length - port.length);\n    }\n    if (host) {\n        this.hostname = host;\n    }\n};\n\n// About 1.5x faster than the two-arg version of Array#splice().\nfunction spliceOne(list, index) {\n    var i = index,\n        k = i + 1,\n        n = list.length;\n\n    for (; k < n; i += 1, k += 1) {\n        list[i] = list[k];\n    }\n    list.pop();\n}\n\nvar hexTable = new Array(256);\nfor (var i = 0; i < 256; ++i) {\n    hexTable[i] = '%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase();\n}\n\nfunction encodeAuth(str) {\n    // faster encodeURIComponent alternative for encoding auth uri components\n    var out = '',\n        lastPos = 0,\n        i, c, c2;\n\n    for (i = 0; i < str.length; ++i) {\n        c = str.charCodeAt(i);\n\n        // These characters do not need escaping:\n        // ! - . _ ~\n        // ' ( ) * :\n        // digits\n        // alpha (uppercase)\n        // alpha (lowercase)\n        if (c === 0x21 || c === 0x2D || c === 0x2E || c === 0x5F || c === 0x7E ||\n            (c >= 0x27 && c <= 0x2A) ||\n            (c >= 0x30 && c <= 0x3A) ||\n            (c >= 0x41 && c <= 0x5A) ||\n            (c >= 0x61 && c <= 0x7A)) {\n            continue;\n        }\n\n        if (i - lastPos > 0) {\n            out += str.slice(lastPos, i);\n        }\n\n        lastPos = i + 1;\n\n        // Other ASCII characters\n        if (c < 0x80) {\n            out += hexTable[c];\n            continue;\n        }\n\n        // Multi-byte characters ...\n        if (c < 0x800) {\n            out += hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)];\n            continue;\n        }\n        if (c < 0xD800 || c >= 0xE000) {\n            out += hexTable[0xE0 | (c >> 12)] +\n                hexTable[0x80 | ((c >> 6) & 0x3F)] +\n                hexTable[0x80 | (c & 0x3F)];\n            continue;\n        }\n        // Surrogate pair\n        ++i;\n        c2;\n        if (i < str.length) {\n            c2 = str.charCodeAt(i) & 0x3FF;\n        } else {\n            c2 = 0;\n        }\n        c = 0x10000 + (((c & 0x3FF) << 10) | c2);\n        out += hexTable[0xF0 | (c >> 18)] +\n            hexTable[0x80 | ((c >> 12) & 0x3F)] +\n            hexTable[0x80 | ((c >> 6) & 0x3F)] +\n            hexTable[0x80 | (c & 0x3F)];\n    }\n    if (lastPos === 0) {\n        return str;\n    }\n    if (lastPos < str.length) {\n        return out + str.slice(lastPos);\n    }\n    return out;\n}\n","module.exports = require(\"./create\")(require(\"./requestBrowser\"));\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\nBuffer.poolSize = 8192 // not used by this implementation\n\nvar rootParent = {}\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Safari 5-7 lacks support for changing the `Object.prototype.constructor` property\n *     on objects.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\nfunction typedArraySupport () {\n  function Bar () {}\n  try {\n    var arr = new Uint8Array(1)\n    arr.foo = function () { return 42 }\n    arr.constructor = Bar\n    return arr.foo() === 42 && // typed array instances can be augmented\n        arr.constructor === Bar && // constructor can be set\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\n/**\n * Class: Buffer\n * =============\n *\n * The Buffer constructor returns instances of `Uint8Array` that are augmented\n * with function properties for all the node `Buffer` API functions. We use\n * `Uint8Array` so that square bracket notation works as expected -- it returns\n * a single octet.\n *\n * By augmenting the instances, we can avoid modifying the `Uint8Array`\n * prototype.\n */\nfunction Buffer (arg) {\n  if (!(this instanceof Buffer)) {\n    // Avoid going through an ArgumentsAdaptorTrampoline in the common case.\n    if (arguments.length > 1) return new Buffer(arg, arguments[1])\n    return new Buffer(arg)\n  }\n\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    this.length = 0\n    this.parent = undefined\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    return fromNumber(this, arg)\n  }\n\n  // Slightly less common case.\n  if (typeof arg === 'string') {\n    return fromString(this, arg, arguments.length > 1 ? arguments[1] : 'utf8')\n  }\n\n  // Unusual.\n  return fromObject(this, arg)\n}\n\nfunction fromNumber (that, length) {\n  that = allocate(that, length < 0 ? 0 : checked(length) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < length; i++) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') encoding = 'utf8'\n\n  // Assumption: byteLength() return value is always < kMaxLength.\n  var length = byteLength(string, encoding) | 0\n  that = allocate(that, length)\n\n  that.write(string, encoding)\n  return that\n}\n\nfunction fromObject (that, object) {\n  if (Buffer.isBuffer(object)) return fromBuffer(that, object)\n\n  if (isArray(object)) return fromArray(that, object)\n\n  if (object == null) {\n    throw new TypeError('must start with number, buffer, array or string')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined') {\n    if (object.buffer instanceof ArrayBuffer) {\n      return fromTypedArray(that, object)\n    }\n    if (object instanceof ArrayBuffer) {\n      return fromArrayBuffer(that, object)\n    }\n  }\n\n  if (object.length) return fromArrayLike(that, object)\n\n  return fromJsonObject(that, object)\n}\n\nfunction fromBuffer (that, buffer) {\n  var length = checked(buffer.length) | 0\n  that = allocate(that, length)\n  buffer.copy(that, 0, 0, length)\n  return that\n}\n\nfunction fromArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Duplicate of fromArray() to keep fromArray() monomorphic.\nfunction fromTypedArray (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  // Truncating the elements is probably not what people expect from typed\n  // arrays with BYTES_PER_ELEMENT > 1 but it's compatible with the behavior\n  // of the old Buffer constructor.\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    array.byteLength\n    that = Buffer._augment(new Uint8Array(array))\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromTypedArray(that, new Uint8Array(array))\n  }\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = checked(array.length) | 0\n  that = allocate(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\n// Deserialize { type: 'Buffer', data: [1,2,3,...] } into a Buffer object.\n// Returns a zero-length buffer for inputs that don't conform to the spec.\nfunction fromJsonObject (that, object) {\n  var array\n  var length = 0\n\n  if (object.type === 'Buffer' && isArray(object.data)) {\n    array = object.data\n    length = checked(array.length) | 0\n  }\n  that = allocate(that, length)\n\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n} else {\n  // pre-set for values that may exist in the future\n  Buffer.prototype.length = undefined\n  Buffer.prototype.parent = undefined\n}\n\nfunction allocate (that, length) {\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = Buffer._augment(new Uint8Array(length))\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that.length = length\n    that._isBuffer = true\n  }\n\n  var fromPool = length !== 0 && length <= Buffer.poolSize >>> 1\n  if (fromPool) that.parent = rootParent\n\n  return that\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (subject, encoding) {\n  if (!(this instanceof SlowBuffer)) return new SlowBuffer(subject, encoding)\n\n  var buf = new Buffer(subject, encoding)\n  delete buf.parent\n  return buf\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  var i = 0\n  var len = Math.min(x, y)\n  while (i < len) {\n    if (a[i] !== b[i]) break\n\n    ++i\n  }\n\n  if (i !== len) {\n    x = a[i]\n    y = b[i]\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'binary':\n    case 'base64':\n    case 'raw':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) throw new TypeError('list argument must be an Array of Buffers.')\n\n  if (list.length === 0) {\n    return new Buffer(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; i++) {\n      length += list[i].length\n    }\n  }\n\n  var buf = new Buffer(length)\n  var pos = 0\n  for (i = 0; i < list.length; i++) {\n    var item = list[i]\n    item.copy(buf, pos)\n    pos += item.length\n  }\n  return buf\n}\n\nfunction byteLength (string, encoding) {\n  if (typeof string !== 'string') string = '' + string\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'binary':\n      // Deprecated\n      case 'raw':\n      case 'raws':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  start = start | 0\n  end = end === undefined || end === Infinity ? this.length : end | 0\n\n  if (!encoding) encoding = 'utf8'\n  if (start < 0) start = 0\n  if (end > this.length) end = this.length\n  if (end <= start) return ''\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'binary':\n        return binarySlice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return 0\n  return Buffer.compare(this, b)\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset) {\n  if (byteOffset > 0x7fffffff) byteOffset = 0x7fffffff\n  else if (byteOffset < -0x80000000) byteOffset = -0x80000000\n  byteOffset >>= 0\n\n  if (this.length === 0) return -1\n  if (byteOffset >= this.length) return -1\n\n  // Negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = Math.max(this.length + byteOffset, 0)\n\n  if (typeof val === 'string') {\n    if (val.length === 0) return -1 // special case: looking for empty string always fails\n    return String.prototype.indexOf.call(this, val, byteOffset)\n  }\n  if (Buffer.isBuffer(val)) {\n    return arrayIndexOf(this, val, byteOffset)\n  }\n  if (typeof val === 'number') {\n    if (Buffer.TYPED_ARRAY_SUPPORT && Uint8Array.prototype.indexOf === 'function') {\n      return Uint8Array.prototype.indexOf.call(this, val, byteOffset)\n    }\n    return arrayIndexOf(this, [ val ], byteOffset)\n  }\n\n  function arrayIndexOf (arr, val, byteOffset) {\n    var foundIndex = -1\n    for (var i = 0; byteOffset + i < arr.length; i++) {\n      if (arr[byteOffset + i] === val[foundIndex === -1 ? 0 : i - foundIndex]) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === val.length) return byteOffset + foundIndex\n      } else {\n        foundIndex = -1\n      }\n    }\n    return -1\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\n// `get` is deprecated\nBuffer.prototype.get = function get (offset) {\n  console.log('.get() is deprecated. Access using array indexes instead.')\n  return this.readUInt8(offset)\n}\n\n// `set` is deprecated\nBuffer.prototype.set = function set (v, offset) {\n  console.log('.set() is deprecated. Access using array indexes instead.')\n  return this.writeUInt8(v, offset)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new Error('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; i++) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) throw new Error('Invalid hex string')\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction binaryWrite (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    var swap = encoding\n    encoding = offset\n    offset = length | 0\n    length = swap\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'binary':\n        return binaryWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction binarySlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; i++) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; i++) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = Buffer._augment(this.subarray(start, end))\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; i++) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  if (newBuf.length) newBuf.parent = this.parent || this\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('buffer must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkInt(this, value, offset, byteLength, Math.pow(2, 8 * byteLength), 0)\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; i++) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; i++) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = value < 0 ? 1 : 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (value > max || value < min) throw new RangeError('value is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('index out of range')\n  if (offset < 0) throw new RangeError('index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; i--) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; i++) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    target._set(this.subarray(start, start + len), targetStart)\n  }\n\n  return len\n}\n\n// fill(value, start=0, end=buffer.length)\nBuffer.prototype.fill = function fill (value, start, end) {\n  if (!value) value = 0\n  if (!start) start = 0\n  if (!end) end = this.length\n\n  if (end < start) throw new RangeError('end < start')\n\n  // Fill 0 bytes; we're done\n  if (end === start) return\n  if (this.length === 0) return\n\n  if (start < 0 || start >= this.length) throw new RangeError('start out of bounds')\n  if (end < 0 || end > this.length) throw new RangeError('end out of bounds')\n\n  var i\n  if (typeof value === 'number') {\n    for (i = start; i < end; i++) {\n      this[i] = value\n    }\n  } else {\n    var bytes = utf8ToBytes(value.toString())\n    var len = bytes.length\n    for (i = start; i < end; i++) {\n      this[i] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n/**\n * Creates a new `ArrayBuffer` with the *copied* memory of the buffer instance.\n * Added in Node 0.12. Only available in browsers that support ArrayBuffer.\n */\nBuffer.prototype.toArrayBuffer = function toArrayBuffer () {\n  if (typeof Uint8Array !== 'undefined') {\n    if (Buffer.TYPED_ARRAY_SUPPORT) {\n      return (new Buffer(this)).buffer\n    } else {\n      var buf = new Uint8Array(this.length)\n      for (var i = 0, len = buf.length; i < len; i += 1) {\n        buf[i] = this[i]\n      }\n      return buf.buffer\n    }\n  } else {\n    throw new TypeError('Buffer.toArrayBuffer not supported in this browser')\n  }\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar BP = Buffer.prototype\n\n/**\n * Augment a Uint8Array *instance* (not the Uint8Array class!) with Buffer methods\n */\nBuffer._augment = function _augment (arr) {\n  arr.constructor = Buffer\n  arr._isBuffer = true\n\n  // save reference to original Uint8Array set method before overwriting\n  arr._set = arr.set\n\n  // deprecated\n  arr.get = BP.get\n  arr.set = BP.set\n\n  arr.write = BP.write\n  arr.toString = BP.toString\n  arr.toLocaleString = BP.toString\n  arr.toJSON = BP.toJSON\n  arr.equals = BP.equals\n  arr.compare = BP.compare\n  arr.indexOf = BP.indexOf\n  arr.copy = BP.copy\n  arr.slice = BP.slice\n  arr.readUIntLE = BP.readUIntLE\n  arr.readUIntBE = BP.readUIntBE\n  arr.readUInt8 = BP.readUInt8\n  arr.readUInt16LE = BP.readUInt16LE\n  arr.readUInt16BE = BP.readUInt16BE\n  arr.readUInt32LE = BP.readUInt32LE\n  arr.readUInt32BE = BP.readUInt32BE\n  arr.readIntLE = BP.readIntLE\n  arr.readIntBE = BP.readIntBE\n  arr.readInt8 = BP.readInt8\n  arr.readInt16LE = BP.readInt16LE\n  arr.readInt16BE = BP.readInt16BE\n  arr.readInt32LE = BP.readInt32LE\n  arr.readInt32BE = BP.readInt32BE\n  arr.readFloatLE = BP.readFloatLE\n  arr.readFloatBE = BP.readFloatBE\n  arr.readDoubleLE = BP.readDoubleLE\n  arr.readDoubleBE = BP.readDoubleBE\n  arr.writeUInt8 = BP.writeUInt8\n  arr.writeUIntLE = BP.writeUIntLE\n  arr.writeUIntBE = BP.writeUIntBE\n  arr.writeUInt16LE = BP.writeUInt16LE\n  arr.writeUInt16BE = BP.writeUInt16BE\n  arr.writeUInt32LE = BP.writeUInt32LE\n  arr.writeUInt32BE = BP.writeUInt32BE\n  arr.writeIntLE = BP.writeIntLE\n  arr.writeIntBE = BP.writeIntBE\n  arr.writeInt8 = BP.writeInt8\n  arr.writeInt16LE = BP.writeInt16LE\n  arr.writeInt16BE = BP.writeInt16BE\n  arr.writeInt32LE = BP.writeInt32LE\n  arr.writeInt32BE = BP.writeInt32BE\n  arr.writeFloatLE = BP.writeFloatLE\n  arr.writeFloatBE = BP.writeFloatBE\n  arr.writeDoubleLE = BP.writeDoubleLE\n  arr.writeDoubleBE = BP.writeDoubleBE\n  arr.fill = BP.fill\n  arr.inspect = BP.inspect\n  arr.toArrayBuffer = BP.toArrayBuffer\n\n  return arr\n}\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; i++) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; i++) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; i++) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n","var isEqual = require(\"@nathanfaucett/is_equal\");\n\n\nmodule.exports = indexOf;\n\n\nfunction indexOf(array, value, fromIndex) {\n    var i = (fromIndex || 0) - 1,\n        il = array.length - 1;\n\n    while (i++ < il) {\n        if (isEqual(array[i], value)) {\n            return i;\n        }\n    }\n\n    return -1;\n}\n","var isNative = require(\"@nathanfaucett/is_native\"),\n    getPrototypeOf = require(\"@nathanfaucett/get_prototype_of\"),\n    isNullOrUndefined = require(\"@nathanfaucett/is_null_or_undefined\");\n\n\nvar nativeHasOwnProp = Object.prototype.hasOwnProperty,\n    baseHas;\n\n\nmodule.exports = has;\n\n\nfunction has(object, key) {\n    if (isNullOrUndefined(object)) {\n        return false;\n    } else {\n        return baseHas(object, key);\n    }\n}\n\nif (isNative(nativeHasOwnProp)) {\n    baseHas = function baseHas(object, key) {\n        if (object.hasOwnProperty) {\n            return object.hasOwnProperty(key);\n        } else {\n            return nativeHasOwnProp.call(object, key);\n        }\n    };\n} else {\n    baseHas = function baseHas(object, key) {\n        var proto = getPrototypeOf(object);\n\n        if (isNullOrUndefined(proto)) {\n            return key in object;\n        } else {\n            return (key in object) && (!(key in proto) || proto[key] !== object[key]);\n        }\n    };\n}\n","var has = require(\"@nathanfaucett/has\"),\n    isNative = require(\"@nathanfaucett/is_native\"),\n    isNullOrUndefined = require(\"@nathanfaucett/is_null_or_undefined\"),\n    isObject = require(\"@nathanfaucett/is_object\");\n\n\nvar nativeKeys = Object.keys;\n\n\nmodule.exports = keys;\n\n\nfunction keys(value) {\n    if (isNullOrUndefined(value)) {\n        return [];\n    } else {\n        return nativeKeys(isObject(value) ? value : Object(value));\n    }\n}\n\nif (!isNative(nativeKeys)) {\n    nativeKeys = function keys(value) {\n        var localHas = has,\n            out = [],\n            i = 0,\n            key;\n\n        for (key in value) {\n            if (localHas(value, key)) {\n                out[i++] = key;\n            }\n        }\n\n        return out;\n    };\n}\n","var isNullOrUndefined = require(\"@nathanfaucett/is_null_or_undefined\");\n\n\nmodule.exports = isPrimitive;\n\n\nfunction isPrimitive(obj) {\n    var typeStr;\n    return isNullOrUndefined(obj) || ((typeStr = typeof(obj)) !== \"object\" && typeStr !== \"function\") || false;\n}\n","var isLength = require(\"@nathanfaucett/is_length\"),\n    isFunction = require(\"@nathanfaucett/is_function\"),\n    isObject = require(\"@nathanfaucett/is_object\");\n\n\nmodule.exports = isArrayLike;\n\n\nfunction isArrayLike(value) {\n    return !isFunction(value) && isObject(value) && isLength(value.length);\n}\n","var isNumber = require(\"@nathanfaucett/is_number\");\n\n\nmodule.exports = Number.isNaN || function isNaN(value) {\n    return isNumber(value) && value !== value;\n};\n","var isNull = require(\"@nathanfaucett/is_null\");\n\n\nmodule.exports = isObject;\n\n\nfunction isObject(value) {\n    var type = typeof(value);\n    return type === \"function\" || (!isNull(value) && type === \"object\") || false;\n}\n","var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n\n;(function (exports) {\n\t'use strict';\n\n  var Arr = (typeof Uint8Array !== 'undefined')\n    ? Uint8Array\n    : Array\n\n\tvar PLUS   = '+'.charCodeAt(0)\n\tvar SLASH  = '/'.charCodeAt(0)\n\tvar NUMBER = '0'.charCodeAt(0)\n\tvar LOWER  = 'a'.charCodeAt(0)\n\tvar UPPER  = 'A'.charCodeAt(0)\n\tvar PLUS_URL_SAFE = '-'.charCodeAt(0)\n\tvar SLASH_URL_SAFE = '_'.charCodeAt(0)\n\n\tfunction decode (elt) {\n\t\tvar code = elt.charCodeAt(0)\n\t\tif (code === PLUS ||\n\t\t    code === PLUS_URL_SAFE)\n\t\t\treturn 62 // '+'\n\t\tif (code === SLASH ||\n\t\t    code === SLASH_URL_SAFE)\n\t\t\treturn 63 // '/'\n\t\tif (code < NUMBER)\n\t\t\treturn -1 //no match\n\t\tif (code < NUMBER + 10)\n\t\t\treturn code - NUMBER + 26 + 26\n\t\tif (code < UPPER + 26)\n\t\t\treturn code - UPPER\n\t\tif (code < LOWER + 26)\n\t\t\treturn code - LOWER + 26\n\t}\n\n\tfunction b64ToByteArray (b64) {\n\t\tvar i, j, l, tmp, placeHolders, arr\n\n\t\tif (b64.length % 4 > 0) {\n\t\t\tthrow new Error('Invalid string. Length must be a multiple of 4')\n\t\t}\n\n\t\t// the number of equal signs (place holders)\n\t\t// if there are two placeholders, than the two characters before it\n\t\t// represent one byte\n\t\t// if there is only one, then the three characters before it represent 2 bytes\n\t\t// this is just a cheap hack to not do indexOf twice\n\t\tvar len = b64.length\n\t\tplaceHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0\n\n\t\t// base64 is 4/3 + up to two characters of the original data\n\t\tarr = new Arr(b64.length * 3 / 4 - placeHolders)\n\n\t\t// if there are placeholders, only get up to the last complete 4 chars\n\t\tl = placeHolders > 0 ? b64.length - 4 : b64.length\n\n\t\tvar L = 0\n\n\t\tfunction push (v) {\n\t\t\tarr[L++] = v\n\t\t}\n\n\t\tfor (i = 0, j = 0; i < l; i += 4, j += 3) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 18) | (decode(b64.charAt(i + 1)) << 12) | (decode(b64.charAt(i + 2)) << 6) | decode(b64.charAt(i + 3))\n\t\t\tpush((tmp & 0xFF0000) >> 16)\n\t\t\tpush((tmp & 0xFF00) >> 8)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\tif (placeHolders === 2) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 2) | (decode(b64.charAt(i + 1)) >> 4)\n\t\t\tpush(tmp & 0xFF)\n\t\t} else if (placeHolders === 1) {\n\t\t\ttmp = (decode(b64.charAt(i)) << 10) | (decode(b64.charAt(i + 1)) << 4) | (decode(b64.charAt(i + 2)) >> 2)\n\t\t\tpush((tmp >> 8) & 0xFF)\n\t\t\tpush(tmp & 0xFF)\n\t\t}\n\n\t\treturn arr\n\t}\n\n\tfunction uint8ToBase64 (uint8) {\n\t\tvar i,\n\t\t\textraBytes = uint8.length % 3, // if we have 1 byte left, pad 2 bytes\n\t\t\toutput = \"\",\n\t\t\ttemp, length\n\n\t\tfunction encode (num) {\n\t\t\treturn lookup.charAt(num)\n\t\t}\n\n\t\tfunction tripletToBase64 (num) {\n\t\t\treturn encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F)\n\t\t}\n\n\t\t// go through the array every three bytes, we'll deal with trailing stuff later\n\t\tfor (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {\n\t\t\ttemp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n\t\t\toutput += tripletToBase64(temp)\n\t\t}\n\n\t\t// pad the end with zeros, but make sure to not forget the extra bytes\n\t\tswitch (extraBytes) {\n\t\t\tcase 1:\n\t\t\t\ttemp = uint8[uint8.length - 1]\n\t\t\t\toutput += encode(temp >> 2)\n\t\t\t\toutput += encode((temp << 4) & 0x3F)\n\t\t\t\toutput += '=='\n\t\t\t\tbreak\n\t\t\tcase 2:\n\t\t\t\ttemp = (uint8[uint8.length - 2] << 8) + (uint8[uint8.length - 1])\n\t\t\t\toutput += encode(temp >> 10)\n\t\t\t\toutput += encode((temp >> 4) & 0x3F)\n\t\t\t\toutput += encode((temp << 2) & 0x3F)\n\t\t\t\toutput += '='\n\t\t\t\tbreak\n\t\t}\n\n\t\treturn output\n\t}\n\n\texports.toByteArray = b64ToByteArray\n\texports.fromByteArray = uint8ToBase64\n}(typeof exports === 'undefined' ? (this.base64js = {}) : exports))\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","module.exports = isEqual;\n\n\nfunction isEqual(a, b) {\n    return !(a !== b && !(a !== a && b !== b));\n}\n","var isFunction = require(\"@nathanfaucett/is_function\"),\n    isNullOrUndefined = require(\"@nathanfaucett/is_null_or_undefined\"),\n    escapeRegExp = require(\"@nathanfaucett/escape_regexp\");\n\n\nvar reHostCtor = /^\\[object .+?Constructor\\]$/,\n\n    functionToString = Function.prototype.toString,\n\n    reNative = RegExp(\"^\" +\n        escapeRegExp(Object.prototype.toString)\n        .replace(/toString|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, \"$1.*?\") + \"$\"\n    ),\n\n    isHostObject;\n\n\nmodule.exports = isNative;\n\n\nfunction isNative(value) {\n    return !isNullOrUndefined(value) && (\n        isFunction(value) ?\n        reNative.test(functionToString.call(value)) : (\n            typeof(value) === \"object\" && (\n                (isHostObject(value) ? reNative : reHostCtor).test(value) || false\n            )\n        )\n    ) || false;\n}\n\ntry {\n    String({\n        \"toString\": 0\n    } + \"\");\n} catch (e) {\n    isHostObject = function isHostObject() {\n        return false;\n    };\n}\n\nisHostObject = function isHostObject(value) {\n    return !isFunction(value.toString) && typeof(value + \"\") === \"string\";\n};\n","var isObject = require(\"@nathanfaucett/is_object\"),\n    isNative = require(\"@nathanfaucett/is_native\"),\n    isNullOrUndefined = require(\"@nathanfaucett/is_null_or_undefined\");\n\n\nvar nativeGetPrototypeOf = Object.getPrototypeOf,\n    baseGetPrototypeOf;\n\n\nmodule.exports = getPrototypeOf;\n\n\nfunction getPrototypeOf(value) {\n    if (isNullOrUndefined(value)) {\n        return null;\n    } else {\n        return baseGetPrototypeOf(value);\n    }\n}\n\nif (isNative(nativeGetPrototypeOf)) {\n    baseGetPrototypeOf = function baseGetPrototypeOf(value) {\n        return nativeGetPrototypeOf(isObject(value) ? value : Object(value)) || null;\n    };\n} else {\n    if (\"\".__proto__ === String.prototype) {\n        baseGetPrototypeOf = function baseGetPrototypeOf(value) {\n            return value.__proto__ || null;\n        };\n    } else {\n        baseGetPrototypeOf = function baseGetPrototypeOf(value) {\n            return value.constructor ? value.constructor.prototype : null;\n        };\n    }\n}\n","var isNull = require(\"@nathanfaucett/is_null\"),\n    isUndefined = require(\"@nathanfaucett/is_undefined\");\n\n\nmodule.exports = isNullOrUndefined;\n\n/**\n  isNullOrUndefined accepts any value and returns true\n  if the value is null or undefined. For all other values\n  false is returned.\n  \n  @param {Any}        any value to test\n  @returns {Boolean}  the boolean result of testing value\n\n  @example\n    isNullOrUndefined(null);   // returns true\n    isNullOrUndefined(undefined);   // returns true\n    isNullOrUndefined(\"string\");    // returns false\n**/\nfunction isNullOrUndefined(value) {\n    return isNull(value) || isUndefined(value);\n}\n","var objectToString = Object.prototype.toString,\n    isFunction;\n\n\nif (objectToString.call(function() {}) === \"[object Object]\") {\n    isFunction = function isFunction(value) {\n        return value instanceof Function;\n    };\n} else if (typeof(/./) === \"function\" || (typeof(Uint8Array) !== \"undefined\" && typeof(Uint8Array) !== \"function\")) {\n    isFunction = function isFunction(value) {\n        return objectToString.call(value) === \"[object Function]\";\n    };\n} else {\n    isFunction = function isFunction(value) {\n        return typeof(value) === \"function\" || false;\n    };\n}\n\n\nmodule.exports = isFunction;\n","var toString = require(\"@nathanfaucett/to_string\");\n\n\nvar reRegExpChars = /[.*+?\\^${}()|\\[\\]\\/\\\\]/g,\n    reHasRegExpChars = new RegExp(reRegExpChars.source);\n\n\nmodule.exports = escapeRegExp;\n\n\nfunction escapeRegExp(string) {\n    string = toString(string);\n    return (\n        (string && reHasRegExpChars.test(string)) ?\n        string.replace(reRegExpChars, \"\\\\$&\") :\n        string\n    );\n}\n","module.exports = isNull;\n\n\nfunction isNull(value) {\n    return value === null;\n}\n","module.exports = isUndefined;\n\n\nfunction isUndefined(value) {\n    return value === void(0);\n}\n","var isString = require(\"@nathanfaucett/is_string\"),\n    isNullOrUndefined = require(\"@nathanfaucett/is_null_or_undefined\");\n\n\nmodule.exports = toString;\n\n\nfunction toString(value) {\n    if (isString(value)) {\n        return value;\n    } else if (isNullOrUndefined(value)) {\n        return \"\";\n    } else {\n        return value + \"\";\n    }\n}\n","module.exports = isString;\n\n\nfunction isString(value) {\n    return typeof(value) === \"string\" || false;\n}\n","var isNumber = require(\"@nathanfaucett/is_number\");\n\n\nvar MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;\n\n\nmodule.exports = isLength;\n\n\nfunction isLength(value) {\n    return isNumber(value) && value > -1 && value % 1 === 0 && value <= MAX_SAFE_INTEGER;\n}\n","module.exports = isNumber;\n\n\nfunction isNumber(value) {\n    return typeof(value) === \"number\" || false;\n}\n","var isNull = require(\"@nathanfaucett/is_null\"),\n    isNative = require(\"@nathanfaucett/is_native\"),\n    isPrimitive = require(\"@nathanfaucett/is_primitive\");\n\n\nvar nativeCreate = Object.create;\n\n\nmodule.exports = create;\n\n\nfunction create(object) {\n    return nativeCreate(isPrimitive(object) ? null : object);\n}\n\nif (!isNative(nativeCreate)) {\n    nativeCreate = function nativeCreate(object) {\n        var newObject;\n\n        function F() {\n            this.constructor = F;\n        }\n\n        if (isNull(object)) {\n            F.prototype = null;\n            newObject = new F();\n            newObject.constructor = newObject.__proto__ = null;\n            delete newObject.__proto__;\n            return newObject;\n        } else {\n            F.prototype = object;\n            return new F();\n        }\n    };\n}\n","/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var methods = require(\"@nathanfaucett/methods\"),\n    arrayForEach = require(\"@nathanfaucett/array-for_each\"),\n    EventEmitter = require(\"@nathanfaucett/event_emitter\"),\n    defaults = require(\"./defaults\");\n\n\nmodule.exports = function createRequest(request) {\n\n    arrayForEach(methods, function(method) {\n        var upper = method.toUpperCase();\n\n        request[method] = function(url, options) {\n            options = options || {};\n\n            options.url = url;\n            options.method = upper;\n\n            return request(options);\n        };\n    });\n    request.mSearch = request[\"m-search\"];\n\n    arrayForEach([\"post\", \"patch\", \"put\"], function(method) {\n        var upper = method.toUpperCase();\n\n        request[method] = function(url, data, options) {\n            options = options || {};\n\n            options.url = url;\n            options.data = data;\n            options.method = upper;\n\n            return request(options);\n        };\n    });\n\n    request.defaults = defaults.values;\n    request.plugins = new EventEmitter(-1);\n\n    return request;\n};\n","var PromisePolyfill = require(\"@nathanfaucett/promise_polyfill\"),\n    XMLHttpRequestPolyfill = require(\"@nathanfaucett/xmlhttprequest_polyfill\"),\n    isFunction = require(\"@nathanfaucett/is_function\"),\n    isString = require(\"@nathanfaucett/is_string\"),\n    isNull = require(\"@nathanfaucett/is_null\"),\n    objectForEach = require(\"@nathanfaucett/object-for_each\"),\n    trim = require(\"@nathanfaucett/trim\"),\n    extend = require(\"@nathanfaucett/extend\"),\n    Response = require(\"./Response\"),\n    defaults = require(\"./defaults\"),\n    camelcaseHeader = require(\"./camelcaseHeader\"),\n    parseContentType = require(\"./parseContentType\");\n\n\nvar supportsFormData = typeof(FormData) !== \"undefined\";\n\n\ndefaults.values.XMLHttpRequest = XMLHttpRequestPolyfill;\n\n\nfunction parseResponseHeaders(responseHeaders) {\n    var headers = {},\n        raw = responseHeaders.split(\"\\n\");\n\n    objectForEach(raw, function(header) {\n        var tmp = header.split(\":\"),\n            key = tmp[0],\n            value = tmp[1];\n\n        if (key && value) {\n            key = camelcaseHeader(key);\n            value = trim(value);\n\n            if (key === \"Content-Length\") {\n                value = +value;\n            }\n\n            headers[key] = value;\n        }\n    });\n\n    return headers;\n}\n\n\nfunction addEventListener(xhr, event, listener) {\n    if (isFunction(xhr.addEventListener)) {\n        xhr.addEventListener(event, listener, false);\n    } else if (isFunction(xhr.attachEvent)) {\n        xhr.attachEvent(\"on\" + event, listener);\n    } else {\n        xhr[\"on\" + event] = listener;\n    }\n}\n\nfunction request(options) {\n    var xhr = new defaults.values.XMLHttpRequest(),\n        plugins = request.plugins,\n        canSetRequestHeader = isFunction(xhr.setRequestHeader),\n        canOverrideMimeType = isFunction(xhr.overrideMimeType),\n        defer = null,\n        isFormData;\n\n    options = defaults(options);\n\n    plugins.emit(\"before\", xhr, options);\n\n    isFormData = (supportsFormData && options.data instanceof FormData);\n\n    if (options.isPromise) {\n        defer = PromisePolyfill.defer();\n    }\n\n    function onSuccess(response) {\n        plugins.emit(\"response\", response, xhr, options);\n        plugins.emit(\"load\", response, xhr, options);\n\n        if (options.isPromise) {\n            defer.resolve(response);\n        } else {\n            if (!isNull(options.success)) {\n                options.success(response);\n            }\n        }\n    }\n\n    function onError(response) {\n        plugins.emit(\"response\", response, xhr, options);\n        plugins.emit(\"error\", response, xhr, options);\n\n        if (options.isPromise) {\n            defer.reject(response);\n        } else {\n            if (!isNull(options.error)) {\n                options.error(response);\n            }\n        }\n    }\n\n    function onComplete() {\n        var statusCode = +xhr.status,\n            responseText = xhr.responseText,\n            response = new Response();\n\n        response.url = xhr.responseURL || options.url;\n        response.method = options.method;\n\n        response.statusCode = statusCode;\n\n        response.responseHeaders = xhr.getAllResponseHeaders ? parseResponseHeaders(xhr.getAllResponseHeaders()) : {};\n        response.requestHeaders = options.headers ? extend({}, options.headers) : {};\n\n        response.data = null;\n\n        if (responseText) {\n            if (options.transformResponse) {\n                response.data = options.transformResponse(responseText);\n            } else {\n                if (parseContentType(response.responseHeaders[\"Content-Type\"]) === \"application/json\") {\n                    try {\n                        response.data = JSON.parse(responseText);\n                    } catch (e) {\n                        response.data = e;\n                        onError(response);\n                        return;\n                    }\n                } else if (responseText) {\n                    response.data = responseText;\n                }\n            }\n        }\n\n        if ((statusCode > 199 && statusCode < 301) || statusCode === 304) {\n            onSuccess(response);\n        } else {\n            onError(response);\n        }\n    }\n\n    function onReadyStateChange() {\n        switch (+xhr.readyState) {\n            case 1:\n                plugins.emit(\"request\", xhr, options);\n                break;\n            case 4:\n                onComplete();\n                break;\n        }\n    }\n\n    addEventListener(xhr, \"readystatechange\", onReadyStateChange);\n\n    if (options.withCredentials && options.async) {\n        xhr.withCredentials = options.withCredentials;\n    }\n\n    xhr.open(\n        options.method,\n        options.url,\n        options.async,\n        options.username,\n        options.password\n    );\n\n    if (canSetRequestHeader) {\n        if (options.headers && options.headers[\"Content-Type\"] && isFormData) {\n            delete options.headers[\"Content-Type\"];\n        }\n\n        objectForEach(options.headers, function(value, key) {\n            if (isString(value)) {\n                if (key === \"Content-Type\" && canOverrideMimeType) {\n                    xhr.overrideMimeType(value);\n                }\n                xhr.setRequestHeader(key, value);\n            }\n        });\n    }\n\n    if (options.transformRequest) {\n        options.data = options.transformRequest(options.data);\n    } else if (options.data) {\n        if (!isString(options.data) && !isFormData) {\n            if (options.headers[\"Content-Type\"] === \"application/json\") {\n                options.data = JSON.stringify(options.data);\n            } else {\n                options.data = options.data + \"\";\n            }\n        }\n    }\n\n    xhr.send(options.data);\n\n    return isNull(defer) ? undefined : defer.promise;\n}\n\n\nmodule.exports = request;\n","module.exports = [\n    \"checkout\",\n    \"connect\",\n    \"copy\",\n    \"delete\",\n    \"get\",\n    \"head\",\n    \"lock\",\n    \"m-search\",\n    \"merge\",\n    \"mkactivity\",\n    \"mkcalendar\",\n    \"mkcol\",\n    \"move\",\n    \"notify\",\n    \"options\",\n    \"patch\",\n    \"post\",\n    \"propfind\",\n    \"proppatch\",\n    \"purge\",\n    \"put\",\n    \"report\",\n    \"search\",\n    \"subscribe\",\n    \"trace\",\n    \"unlock\",\n    \"unsubscribe\"\n];\n","module.exports = arrayForEach;\n\n\nfunction arrayForEach(array, callback) {\n    var i = -1,\n        il = array.length - 1;\n\n    while (i++ < il) {\n        if (callback(array[i], i, array) === false) {\n            break;\n        }\n    }\n\n    return array;\n}\n","var isFunction = require(\"@nathanfaucett/is_function\"),\n    inherits = require(\"@nathanfaucett/inherits\"),\n    fastSlice = require(\"@nathanfaucett/fast_slice\"),\n    keys = require(\"@nathanfaucett/keys\"),\n    isNumber = require(\"@nathanfaucett/is_number\"),\n    isNullOrUndefined = require(\"@nathanfaucett/is_null_or_undefined\");\n\n\nvar EventEmitterPrototype;\n\n\nmodule.exports = EventEmitter;\n\n\nfunction EventEmitter(maxListeners) {\n    this.__events = {};\n    this.__maxListeners = isNumber(maxListeners) ? +maxListeners : EventEmitter.defaultMaxListeners;\n}\nEventEmitterPrototype = EventEmitter.prototype;\n\nEventEmitterPrototype.on = function(name, listener) {\n    var events, eventList, maxListeners;\n\n    if (!isFunction(listener)) {\n        throw new TypeError(\"EventEmitter.on(name, listener) listener must be a function\");\n    }\n\n    events = this.__events || (this.__events = {});\n    eventList = (events[name] || (events[name] = []));\n    maxListeners = this.__maxListeners || -1;\n\n    eventList[eventList.length] = listener;\n\n    if (maxListeners !== -1 && eventList.length > maxListeners) {\n        console.error(\n            \"EventEmitter.on(type, listener) possible EventEmitter memory leak detected. \" + maxListeners + \" listeners added\"\n        );\n    }\n\n    return this;\n};\n\nEventEmitterPrototype.addEventListener = EventEmitterPrototype.addListener = EventEmitterPrototype.on;\n\nEventEmitterPrototype.once = function(name, listener) {\n    var _this = this;\n\n    function once() {\n\n        _this.off(name, once);\n\n        switch (arguments.length) {\n            case 0:\n                return listener();\n            case 1:\n                return listener(arguments[0]);\n            case 2:\n                return listener(arguments[0], arguments[1]);\n            case 3:\n                return listener(arguments[0], arguments[1], arguments[2]);\n            case 4:\n                return listener(arguments[0], arguments[1], arguments[2], arguments[3]);\n            default:\n                return listener.apply(null, arguments);\n        }\n    }\n\n    this.on(name, once);\n\n    return once;\n};\n\nEventEmitterPrototype.listenTo = function(value, name) {\n    var _this = this;\n\n    if (!value || !(isFunction(value.on) || isFunction(value.addListener))) {\n        throw new TypeError(\"EventEmitter.listenTo(value, name) value must have a on function taking (name, listener[, ctx])\");\n    }\n\n    function handler() {\n        _this.emitArgs(name, arguments);\n    }\n\n    value.on(name, handler);\n\n    return handler;\n};\n\nEventEmitterPrototype.off = function(name, listener) {\n    var events = this.__events || (this.__events = {}),\n        eventList, event, i;\n\n    eventList = events[name];\n    if (!eventList) {\n        return this;\n    }\n\n    if (!listener) {\n        i = eventList.length;\n\n        while (i--) {\n            this.emit(\"removeListener\", name, eventList[i]);\n        }\n        eventList.length = 0;\n        delete events[name];\n    } else {\n        i = eventList.length;\n\n        while (i--) {\n            event = eventList[i];\n\n            if (event === listener) {\n                this.emit(\"removeListener\", name, event);\n                eventList.splice(i, 1);\n            }\n        }\n\n        if (eventList.length === 0) {\n            delete events[name];\n        }\n    }\n\n    return this;\n};\n\nEventEmitterPrototype.removeEventListener = EventEmitterPrototype.removeListener = EventEmitterPrototype.off;\n\nEventEmitterPrototype.removeAllListeners = function() {\n    var events = this.__events || (this.__events = {}),\n        objectKeys = keys(events),\n        i = -1,\n        il = objectKeys.length - 1,\n        key, eventList, j;\n\n    while (i++ < il) {\n        key = objectKeys[i];\n        eventList = events[key];\n\n        if (eventList) {\n            j = eventList.length;\n\n            while (j--) {\n                this.emit(\"removeListener\", key, eventList[j]);\n                eventList.splice(j, 1);\n            }\n        }\n\n        delete events[key];\n    }\n\n    return this;\n};\n\nEventEmitterPrototype.dispatchEvent = function(event) {\n    return this.emitArg(event.type, event);\n};\n\nEventEmitterPrototype.attachEvent = function(type, listener) {\n    return this.on(type.slice(2), listener);\n};\n\nEventEmitterPrototype.detachEvent = function(type, listener) {\n    return this.off(type.slice(2), listener);\n};\n\nEventEmitterPrototype.fireEvent = function(type, event) {\n    return this.emitArg(type.slice(2), event);\n};\n\nfunction emit0(eventList) {\n    var i = -1,\n        il = eventList.length - 1,\n        event;\n\n    while (i++ < il) {\n        if ((event = eventList[i])) {\n            event();\n        }\n    }\n}\n\nfunction emit1(eventList, a0) {\n    var i = -1,\n        il = eventList.length - 1,\n        event;\n\n    while (i++ < il) {\n        if ((event = eventList[i])) {\n            event(a0);\n        }\n    }\n}\n\nfunction emit2(eventList, args) {\n    var a0 = args[0],\n        a1 = args[1],\n        i = -1,\n        il = eventList.length - 1,\n        event;\n\n    while (i++ < il) {\n        if ((event = eventList[i])) {\n            event(a0, a1);\n        }\n    }\n}\n\nfunction emit3(eventList, args) {\n    var a0 = args[0],\n        a1 = args[1],\n        a2 = args[2],\n        i = -1,\n        il = eventList.length - 1,\n        event;\n\n    while (i++ < il) {\n        if ((event = eventList[i])) {\n            event(a0, a1, a2);\n        }\n    }\n}\n\nfunction emit4(eventList, args) {\n    var a0 = args[0],\n        a1 = args[1],\n        a2 = args[2],\n        a3 = args[3],\n        i = -1,\n        il = eventList.length - 1,\n        event;\n\n    while (i++ < il) {\n        if ((event = eventList[i])) {\n            event(a0, a1, a2, a3);\n        }\n    }\n}\n\nfunction emit5(eventList, args) {\n    var a0 = args[0],\n        a1 = args[1],\n        a2 = args[2],\n        a3 = args[3],\n        a4 = args[4],\n        i = -1,\n        il = eventList.length - 1,\n        event;\n\n    while (i++ < il) {\n        if ((event = eventList[i])) {\n            event(a0, a1, a2, a3, a4);\n        }\n    }\n}\n\nfunction emitApply(eventList, args) {\n    var i = -1,\n        il = eventList.length - 1,\n        event;\n\n    while (i++ < il) {\n        if ((event = eventList[i])) {\n            event.apply(null, args);\n        }\n    }\n}\n\nfunction emit(eventList, args) {\n    switch (args.length) {\n        case 0:\n            emit0(eventList);\n            break;\n        case 1:\n            emit1(eventList, args[0]);\n            break;\n        case 2:\n            emit2(eventList, args);\n            break;\n        case 3:\n            emit3(eventList, args);\n            break;\n        case 4:\n            emit4(eventList, args);\n            break;\n        case 5:\n            emit5(eventList, args);\n            break;\n        default:\n            emitApply(eventList, args);\n            break;\n    }\n}\n\nEventEmitterPrototype.emitArg = function(name, arg) {\n    var eventList = (this.__events || (this.__events = {}))[name];\n\n    if (!eventList || !eventList.length) {\n        return this;\n    } else {\n        emit1(eventList, arg);\n        return this;\n    }\n};\n\nEventEmitterPrototype.emitArgs = function(name, args) {\n    var eventList = (this.__events || (this.__events = {}))[name];\n\n    if (!eventList || !eventList.length) {\n        return this;\n    } else {\n        emit(eventList, args);\n        return this;\n    }\n};\n\nEventEmitterPrototype.emit = function(name) {\n    return this.emitArgs(name, fastSlice(arguments, 1));\n};\n\nfunction createFunctionCaller(args) {\n    var a0, a1, a2, a3, a4;\n    switch (args.length) {\n        case 0:\n            return function functionCaller(fn) {\n                return fn();\n            };\n        case 1:\n            a0 = args[0];\n            return function functionCaller(fn) {\n                return fn(a0);\n            };\n        case 2:\n            a0 = args[0];\n            a1 = args[1];\n            return function functionCaller(fn) {\n                return fn(a0, a1);\n            };\n        case 3:\n            a0 = args[0];\n            a1 = args[1];\n            a2 = args[2];\n            return function functionCaller(fn) {\n                return fn(a0, a1, a2);\n            };\n        case 4:\n            a0 = args[0];\n            a1 = args[1];\n            a2 = args[2];\n            a3 = args[3];\n            return function functionCaller(fn) {\n                return fn(a0, a1, a2, a3);\n            };\n        case 5:\n            a0 = args[0];\n            a1 = args[1];\n            a2 = args[2];\n            a3 = args[3];\n            a4 = args[4];\n            return function functionCaller(fn) {\n                return fn(a0, a1, a2, a3, a4);\n            };\n        default:\n            return function functionCaller(fn) {\n                return fn.apply(null, args);\n            };\n    }\n}\n\nfunction emitAsync(eventList, args, callback) {\n    var length = eventList.length,\n        index = 0,\n        called = false,\n        functionCaller;\n\n    function next(error) {\n        if (called !== true) {\n            if (error || index === length) {\n                called = true;\n                callback(error);\n            } else {\n                functionCaller(eventList[index++]);\n            }\n        }\n    }\n\n    args[args.length] = next;\n    functionCaller = createFunctionCaller(args);\n    next();\n}\n\nEventEmitterPrototype.emitAsync = function(name, args, callback) {\n    var eventList = (this.__events || (this.__events = {}))[name];\n\n    args = fastSlice(arguments, 1);\n    callback = args.pop();\n\n    if (!isFunction(callback)) {\n        throw new TypeError(\"EventEmitter.emitAsync(name [, ...args], callback) callback must be a function\");\n    } else {\n        if (!eventList || !eventList.length) {\n            callback();\n        } else {\n            emitAsync(eventList, args, callback);\n        }\n        return this;\n    }\n};\n\nEventEmitterPrototype.listeners = function(name) {\n    var eventList = (this.__events || (this.__events = {}))[name];\n    return eventList ? eventList.slice() : [];\n};\n\nEventEmitterPrototype.listenerCount = function(name) {\n    var eventList = (this.__events || (this.__events = {}))[name];\n    return eventList ? eventList.length : 0;\n};\n\nEventEmitterPrototype.setMaxListeners = function(value) {\n    if ((value = +value) !== value) {\n        throw new TypeError(\"EventEmitter.setMaxListeners(value) value must be a number\");\n    }\n\n    this.__maxListeners = value < 0 ? -1 : value;\n    return this;\n};\n\ninherits.defineProperty(EventEmitter, \"defaultMaxListeners\", 10);\n\ninherits.defineProperty(EventEmitter, \"listeners\", function(value, name) {\n    var eventList;\n\n    if (isNullOrUndefined(value)) {\n        throw new TypeError(\"EventEmitter.listeners(value, name) value required\");\n    }\n    eventList = value.__events && value.__events[name];\n\n    return eventList ? eventList.slice() : [];\n});\n\ninherits.defineProperty(EventEmitter, \"listenerCount\", function(value, name) {\n    var eventList;\n\n    if (isNullOrUndefined(value)) {\n        throw new TypeError(\"EventEmitter.listenerCount(value, name) value required\");\n    }\n    eventList = value.__events && value.__events[name];\n\n    return eventList ? eventList.length : 0;\n});\n\ninherits.defineProperty(EventEmitter, \"setMaxListeners\", function(value) {\n    if ((value = +value) !== value) {\n        throw new TypeError(\"EventEmitter.setMaxListeners(value) value must be a number\");\n    }\n\n    EventEmitter.defaultMaxListeners = value < 0 ? -1 : value;\n    return value;\n});\n\nEventEmitter.extend = function(child) {\n    inherits(child, this);\n    return child;\n};\n","var extend = require(\"@nathanfaucett/extend\"),\n    isString = require(\"@nathanfaucett/is_string\"),\n    isFunction = require(\"@nathanfaucett/is_function\");\n\n\nfunction defaults(options) {\n\n    options = extend({}, defaults.values, options);\n\n    options.url = isString(options.url || (options.url = options.src)) ? options.url : null;\n    options.method = isString(options.method) ? options.method.toUpperCase() : \"GET\";\n\n    options.transformRequest = isFunction(options.transformRequest) ? options.transformRequest : null;\n    options.transformResponse = isFunction(options.transformResponse) ? options.transformResponse : null;\n\n    options.withCredentials = options.withCredentials != null ? !!options.withCredentials : false;\n    options.headers = extend({}, defaults.values.headers, options.headers);\n    options.async = options.async != null ? !!options.async : true;\n\n    options.success = isFunction(options.success) ? options.success : null;\n    options.error = isFunction(options.error) ? options.error : null;\n    options.isPromise = !isFunction(options.success) && !isFunction(options.error);\n\n    options.user = isString(options.user) ? options.user : undefined;\n    options.password = isString(options.password) ? options.password : undefined;\n\n    return options;\n}\n\ndefaults.values = {\n    url: \"\",\n    method: \"GET\",\n    data: null,\n    headers: {\n        Accept: \"*/*\",\n        \"X-Requested-With\": \"XMLHttpRequest\"\n    }\n};\n\n\nmodule.exports = defaults;\n","var create = require(\"@nathanfaucett/create\"),\n    extend = require(\"@nathanfaucett/extend\"),\n    mixin = require(\"@nathanfaucett/mixin\"),\n    defineProperty = require(\"@nathanfaucett/define_property\");\n\n\nvar descriptor = {\n    configurable: true,\n    enumerable: false,\n    writable: true,\n    value: null\n};\n\n\nmodule.exports = inherits;\n\n\nfunction inherits(child, parent) {\n\n    mixin(child, parent);\n\n    if (child.__super) {\n        child.prototype = extend(create(parent.prototype), child.__super, child.prototype);\n    } else {\n        child.prototype = extend(create(parent.prototype), child.prototype);\n    }\n\n    defineNonEnumerableProperty(child, \"__super\", parent.prototype);\n    defineNonEnumerableProperty(child.prototype, \"constructor\", child);\n\n    child.defineStatic = defineStatic;\n    child.super_ = parent;\n\n    return child;\n}\ninherits.defineProperty = defineNonEnumerableProperty;\n\nfunction defineNonEnumerableProperty(object, name, value) {\n    descriptor.value = value;\n    defineProperty(object, name, descriptor);\n    descriptor.value = null;\n}\n\nfunction defineStatic(name, value) {\n    defineNonEnumerableProperty(this, name, value);\n}\n","var clamp = require(\"@nathanfaucett/clamp\"),\n    isNumber = require(\"@nathanfaucett/is_number\");\n\n\nmodule.exports = fastSlice;\n\n\nfunction fastSlice(array, offset) {\n    var length = array.length,\n        newLength, i, il, result, j;\n\n    offset = clamp(isNumber(offset) ? offset : 0, 0, length);\n    i = offset - 1;\n    il = length - 1;\n    newLength = length - offset;\n    result = new Array(newLength);\n    j = 0;\n\n    while (i++ < il) {\n        result[j++] = array[i];\n    }\n\n    return result;\n}\n","var keys = require(\"@nathanfaucett/keys\"),\n    isNative = require(\"@nathanfaucett/is_native\");\n\n\nvar nativeAssign = Object.assign,\n    extend, baseExtend;\n\n\nif (isNative(nativeAssign)) {\n    extend = nativeAssign;\n} else {\n    extend = function extend(out) {\n        var i = 0,\n            il = arguments.length - 1;\n\n        while (i++ < il) {\n            baseExtend(out, arguments[i]);\n        }\n\n        return out;\n    };\n    baseExtend = function baseExtend(a, b) {\n        var objectKeys = keys(b),\n            i = -1,\n            il = objectKeys.length - 1,\n            key;\n\n        while (i++ < il) {\n            key = objectKeys[i];\n            a[key] = b[key];\n        }\n    };\n}\n\n\nmodule.exports = extend;\n","var keys = require(\"@nathanfaucett/keys\"),\n    isNullOrUndefined = require(\"@nathanfaucett/is_null_or_undefined\");\n\n\nmodule.exports = mixin;\n\n\nfunction mixin(out) {\n    var i = 0,\n        il = arguments.length - 1;\n\n    while (i++ < il) {\n        baseMixin(out, arguments[i]);\n    }\n\n    return out;\n}\n\nfunction baseMixin(a, b) {\n    var objectKeys = keys(b),\n        i = -1,\n        il = objectKeys.length - 1,\n        key, value;\n\n    while (i++ < il) {\n        key = objectKeys[i];\n\n        if (isNullOrUndefined(a[key]) && !isNullOrUndefined((value = b[key]))) {\n            a[key] = value;\n        }\n    }\n}\n","var isObject = require(\"@nathanfaucett/is_object\"),\n    isFunction = require(\"@nathanfaucett/is_function\"),\n    isPrimitive = require(\"@nathanfaucett/is_primitive\"),\n    isNative = require(\"@nathanfaucett/is_native\"),\n    has = require(\"@nathanfaucett/has\");\n\n\nvar nativeDefineProperty = Object.defineProperty;\n\n\nmodule.exports = defineProperty;\n\n\nfunction defineProperty(object, name, descriptor) {\n    if (isPrimitive(descriptor) || isFunction(descriptor)) {\n        descriptor = {\n            value: descriptor\n        };\n    }\n    return nativeDefineProperty(object, name, descriptor);\n}\n\ndefineProperty.hasGettersSetters = true;\n\nif (!isNative(nativeDefineProperty) || !(function() {\n        var object = {},\n            value = {};\n\n        try {\n            nativeDefineProperty(object, \"key\", {\n                value: value\n            });\n            if (has(object, \"key\") && object.key === value) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (e) {}\n\n        return false;\n    }())) {\n\n    defineProperty.hasGettersSetters = false;\n\n    nativeDefineProperty = function defineProperty(object, name, descriptor) {\n        if (!isObject(object)) {\n            throw new TypeError(\"defineProperty(object, name, descriptor) called on non-object\");\n        }\n        if (has(descriptor, \"get\") || has(descriptor, \"set\")) {\n            throw new TypeError(\"defineProperty(object, name, descriptor) this environment does not support getters or setters\");\n        }\n        object[name] = descriptor.value;\n    };\n}\n","var has = require(\"@nathanfaucett/has\"),\n    isNative = require(\"@nathanfaucett/is_native\"),\n    isNullOrUndefined = require(\"@nathanfaucett/is_null_or_undefined\"),\n    isObject = require(\"@nathanfaucett/is_object\");\n\n\nvar nativeKeys = Object.keys;\n\n\nmodule.exports = keys;\n\n\nfunction keys(value) {\n    if (isNullOrUndefined(value)) {\n        return [];\n    } else {\n        return nativeKeys(isObject(value) ? value : Object(value));\n    }\n}\n\nif (!isNative(nativeKeys)) {\n    nativeKeys = function keys(value) {\n        var localHas = has,\n            out = [],\n            i = 0,\n            key;\n\n        for (key in value) {\n            if (localHas(value, key)) {\n                out[i++] = key;\n            }\n        }\n\n        return out;\n    };\n}\n","var isNative = require(\"@nathanfaucett/is_native\"),\n    getPrototypeOf = require(\"@nathanfaucett/get_prototype_of\"),\n    isNullOrUndefined = require(\"@nathanfaucett/is_null_or_undefined\");\n\n\nvar nativeHasOwnProp = Object.prototype.hasOwnProperty,\n    baseHas;\n\n\nmodule.exports = has;\n\n\nfunction has(object, key) {\n    if (isNullOrUndefined(object)) {\n        return false;\n    } else {\n        return baseHas(object, key);\n    }\n}\n\nif (isNative(nativeHasOwnProp)) {\n    baseHas = function baseHas(object, key) {\n        if (object.hasOwnProperty) {\n            return object.hasOwnProperty(key);\n        } else {\n            return nativeHasOwnProp.call(object, key);\n        }\n    };\n} else {\n    baseHas = function baseHas(object, key) {\n        var proto = getPrototypeOf(object);\n\n        if (isNullOrUndefined(proto)) {\n            return key in object;\n        } else {\n            return (key in object) && (!(key in proto) || proto[key] !== object[key]);\n        }\n    };\n}\n","module.exports = clamp;\n\n\nfunction clamp(x, min, max) {\n    if (x < min) {\n        return min;\n    } else if (x > max) {\n        return max;\n    } else {\n        return x;\n    }\n}\n","var isNull = require(\"@nathanfaucett/is_null\"),\n    isArray = require(\"@nathanfaucett/is_array\"),\n    isObject = require(\"@nathanfaucett/is_object\"),\n    isFunction = require(\"@nathanfaucett/is_function\"),\n    apply = require(\"@nathanfaucett/apply\"),\n    WeakMapPolyfill = require(\"@nathanfaucett/weak_map_polyfill\"),\n    fastSlice = require(\"@nathanfaucett/fast_slice\"),\n    Iterator = require(\"@nathanfaucett/iterator\");\n\n\nvar PromisePolyfill, PromisePolyfillPrototype, PrivatePromise, Defer;\n\n\nif (\n    typeof(Promise) !== \"undefined\" &&\n    (function isValidPromise() {\n        try {\n            new Promise(function resolver(resolve) {\n                resolve(true);\n            }).then(function onThen() {});\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }())\n) {\n    PromisePolyfill = Promise;\n    PromisePolyfillPrototype = PromisePolyfill.prototype;\n} else {\n    PrivatePromise = (function createPrivatePromise() {\n\n        function PrivatePromise(resolver) {\n            var _this = this;\n\n            this.handlers = [];\n            this.state = null;\n            this.value = null;\n\n            handleResolve(\n                resolver,\n                function resolve(newValue) {\n                    resolveValue(_this, newValue);\n                },\n                function reject(newValue) {\n                    rejectValue(_this, newValue);\n                }\n            );\n        }\n\n        PrivatePromise.store = new WeakMapPolyfill();\n\n        PrivatePromise.handle = function(_this, onFulfilled, onRejected, resolve, reject) {\n            handle(_this, new Handler(onFulfilled, onRejected, resolve, reject));\n        };\n\n        function Handler(onFulfilled, onRejected, resolve, reject) {\n            this.onFulfilled = isFunction(onFulfilled) ? onFulfilled : null;\n            this.onRejected = isFunction(onRejected) ? onRejected : null;\n            this.resolve = resolve;\n            this.reject = reject;\n        }\n\n        function handleResolve(resolver, onFulfilled, onRejected) {\n            var done = false;\n\n            try {\n                resolver(\n                    function(value) {\n                        if (!done) {\n                            done = true;\n                            onFulfilled(value);\n                        }\n                    },\n                    function(reason) {\n                        if (!done) {\n                            done = true;\n                            onRejected(reason);\n                        }\n                    }\n                );\n            } catch (err) {\n                if (!done) {\n                    done = true;\n                    onRejected(err);\n                }\n            }\n        }\n\n        function resolveValue(_this, newValue) {\n            try {\n                if (newValue === _this) {\n                    throw new TypeError(\"A promise cannot be resolved with itself\");\n                } else {\n                    if (newValue && (isObject(newValue) || isFunction(newValue))) {\n                        if (isFunction(newValue.then)) {\n                            handleResolve(\n                                function resolver(resolve, reject) {\n                                    newValue.then(resolve, reject);\n                                },\n                                function resolve(newValue) {\n                                    resolveValue(_this, newValue);\n                                },\n                                function reject(newValue) {\n                                    rejectValue(_this, newValue);\n                                }\n                            );\n                            return;\n                        }\n                    }\n                    _this.state = true;\n                    _this.value = newValue;\n                    finale(_this);\n                }\n            } catch (error) {\n                rejectValue(_this, error);\n            }\n        }\n\n        function rejectValue(_this, newValue) {\n            _this.state = false;\n            _this.value = newValue;\n            finale(_this);\n        }\n\n        function finale(_this) {\n            var handlers = _this.handlers,\n                i = -1,\n                il = handlers.length - 1;\n\n            while (i++ < il) {\n                handle(_this, handlers[i]);\n            }\n\n            handlers.length = 0;\n        }\n\n        function handle(_this, handler) {\n            var state = _this.state;\n\n            if (isNull(_this.state)) {\n                _this.handlers.push(handler);\n            } else {\n                process.nextTick(function onNextTick() {\n                    var callback = state ? handler.onFulfilled : handler.onRejected,\n                        value = _this.value,\n                        out;\n\n                    if (isNull(callback)) {\n                        if (state) {\n                            handler.resolve(value);\n                        } else {\n                            handler.reject(value);\n                        }\n                    } else {\n                        try {\n                            out = callback(value);\n                            handler.resolve(out);\n                        } catch (err) {\n                            handler.reject(err);\n                        }\n                    }\n                });\n            }\n        }\n\n        return PrivatePromise;\n    }());\n\n    PromisePolyfill = function Promise(resolver) {\n\n        if (!isFunction(resolver)) {\n            throw new TypeError(\"Promise(resolver) You must pass a resolver function as the first argument to the promise constructor\");\n        }\n\n        PrivatePromise.store.set(this, new PrivatePromise(resolver));\n    };\n\n    PromisePolyfillPrototype = PromisePolyfill.prototype;\n\n    PromisePolyfillPrototype.then = function(onFulfilled, onRejected) {\n        var _this = PrivatePromise.store.get(this);\n\n        return new PromisePolyfill(function resolver(resolve, reject) {\n            PrivatePromise.handle(_this, onFulfilled, onRejected, resolve, reject);\n        });\n    };\n}\n\nif (!isFunction(PromisePolyfillPrototype[\"catch\"])) {\n    PromisePolyfillPrototype[\"catch\"] = function(reject) {\n        return this.then(null, reject);\n    };\n}\n\nif (!isFunction(PromisePolyfill.resolve)) {\n    PromisePolyfill.resolve = function(value) {\n        if (value instanceof PromisePolyfill) {\n            return value;\n        }\n\n        return new PromisePolyfill(function resolver(resolve) {\n            resolve(value);\n        });\n    };\n}\n\nif (!isFunction(PromisePolyfill.reject)) {\n    PromisePolyfill.reject = function(value) {\n        return new PromisePolyfill(function resolver(resolve, reject) {\n            reject(value);\n        });\n    };\n}\n\nif (!isFunction(PromisePolyfill.defer)) {\n    Defer = function Defer() {\n        var _this = this;\n\n        this.resolve = null;\n        this.reject = null;\n\n        this.promise = new PromisePolyfill(function resolver(resolve, reject) {\n            _this.resolve = resolve;\n            _this.reject = reject;\n        });\n    };\n\n    PromisePolyfill.defer = function() {\n        return new Defer();\n    };\n}\n\nif (!isFunction(PromisePolyfill.all)) {\n    PromisePolyfill.all = function(value) {\n        var values = (arguments.length === 1 && isArray(value)) ? value : fastSlice(arguments);\n\n        return new PromisePolyfill(function resolver(resolve, reject) {\n            var iterator = Iterator.getIterator(values),\n                called = false,\n                count = 0,\n                it, step, value, resolveFn, rejectFn, results;\n\n            if (iterator) {\n                it = iterator.call(values);\n\n                resolveFn = function resolveFn(value) {\n                    if (!called) {\n                        results = results || [];\n                        results[results.length] = value;\n\n                        if (--count === 0) {\n                            called = true;\n                            resolve(results);\n                        }\n                    }\n                };\n                rejectFn = function rejectFn(value) {\n                    if (!called) {\n                        called = true;\n                        reject(value);\n                    }\n                };\n\n                while (!(step = it.next()).done) {\n                    count++;\n                    value = step.value;\n\n                    if (value && isFunction(value.then)) {\n                        value.then(resolveFn, rejectFn);\n                    } else {\n                        resolveFn(value);\n                    }\n                }\n            } else {\n                reject(new Error(\"Invalid Iterator \" + typeof(values)));\n            }\n        });\n    };\n}\n\nif (!isFunction(PromisePolyfill.race)) {\n    PromisePolyfill.race = function(value) {\n        var values = (arguments.length === 1 && isArray(value)) ? value : fastSlice(arguments);\n\n        return new PromisePolyfill(function resolver(resolve, reject) {\n            var iterator = Iterator.getIterator(values),\n                it, step, value;\n\n            if (iterator) {\n                it = iterator.call(values);\n\n                while (!(step = it.next()).done) {\n                    value = step.value;\n\n                    if (value && isFunction(value.then)) {\n                        value.then(resolve, reject);\n                    } else {\n                        resolve(value);\n                    }\n                }\n            } else {\n                reject(new Error(\"Invalid Iterator \" + typeof(values)));\n            }\n        });\n    };\n}\n\nif (!isFunction(PromisePolyfill.promisify)) {\n    PromisePolyfill.promisify = function(fn, thisArg) {\n        return function promisified() {\n            var defer = PromisePolyfill.defer(),\n                args = fastSlice(arguments);\n\n            function callback(error, value) {\n                if (error) {\n                    return defer.reject(error);\n                } else {\n                    if (arguments.length < 3) {\n                        return defer.resolve(value);\n                    } else {\n                        return defer.resolve(fastSlice(arguments, 1));\n                    }\n                }\n            }\n\n            args[args.length] = callback;\n            apply(fn, args, thisArg);\n\n            return defer.promise;\n        };\n    };\n}\n\n\nmodule.exports = PromisePolyfill;","var extend = require(\"@nathanfaucett/extend\"),\n    EventEmitter = require(\"@nathanfaucett/event_emitter\"),\n    EventPolyfill = require(\"./EventPolyfill\"),\n    ProgressEventPolyfill = require(\"./ProgressEventPolyfill\"),\n    tryCallFunction = require(\"./tryCallFunction\"),\n    trySetValue = require(\"./trySetValue\"),\n    emitEvent = require(\"./emitEvent\"),\n    toUint8Array = require(\"./toUint8Array\"),\n    createNativeXMLHttpRequest = require(\"./createNativeXMLHttpRequest\");\n\n\nvar hasNativeProgress = false,\n    XMLHttpRequestPolyfillPrototype;\n\n\nmodule.exports = XMLHttpRequestPolyfill;\n\n\nfunction XMLHttpRequestPolyfill(options) {\n    var _this = this,\n        nativeXMLHttpRequest = createNativeXMLHttpRequest(options || {});\n\n    EventEmitter.call(this, -1);\n\n    this.__requestHeaders = {};\n    this.__nativeXMLHttpRequest = nativeXMLHttpRequest;\n\n    this.onabort = null;\n    this.onerror = null;\n    this.onload = null;\n    this.onloadend = null;\n    this.onloadstart = null;\n    this.onprogress = null;\n    this.onreadystatechange = null;\n    this.ontimeout = null;\n\n    this.readyState = 0;\n    this.response = \"\";\n    this.responseText = \"\";\n    this.responseType = \"\";\n    this.responseURL = \"\";\n    this.responseXML = null;\n    this.status = 0;\n    this.statusText = \"\";\n    this.timeout = 0;\n    this.withCredentials = false;\n\n    nativeXMLHttpRequest.onreadystatechange = function(e) {\n        return XMLHttpRequestPolyfill_onReadyStateChange(_this, e || {});\n    };\n\n    nativeXMLHttpRequest.ontimeout = function(e) {\n        emitEvent(_this, \"timeout\", new EventPolyfill(\"timeout\", e || {}));\n    };\n\n    nativeXMLHttpRequest.onerror = function(e) {\n        emitEvent(_this, \"error\", new EventPolyfill(\"error\", e || {}));\n    };\n\n    if (\"onprogress\" in nativeXMLHttpRequest) {\n        hasNativeProgress = true;\n        nativeXMLHttpRequest.onprogress = function(e) {\n            emitEvent(_this, \"progress\", new ProgressEventPolyfill(\"progress\", e || {}));\n        };\n    }\n}\nEventEmitter.extend(XMLHttpRequestPolyfill);\nXMLHttpRequestPolyfillPrototype = XMLHttpRequestPolyfill.prototype;\n\n\nfunction XMLHttpRequestPolyfill_onReadyStateChange(_this, e) {\n    var nativeXMLHttpRequest = _this.__nativeXMLHttpRequest,\n        response;\n\n    _this.readyState = nativeXMLHttpRequest.readyState;\n\n    switch (nativeXMLHttpRequest.readyState) {\n        case 1:\n            emitEvent(_this, \"loadstart\", new EventPolyfill(\"loadstart\", e));\n            break;\n        case 3:\n            XMLHttpRequestPolyfill_onProgress(_this, e);\n            break;\n        case 4:\n            response = nativeXMLHttpRequest.response || \"\";\n\n            _this.response = response;\n\n            _this.status = nativeXMLHttpRequest.status || 0;\n            _this.statusText = nativeXMLHttpRequest.statusText || \"\";\n\n            if (nativeXMLHttpRequest.responseType !== \"arraybuffer\") {\n                _this.responseText = nativeXMLHttpRequest.responseText || response;\n                _this.responseXML = nativeXMLHttpRequest.responseXML || response;\n            } else {\n                _this.responseText = \"\";\n                _this.responseXML = \"\";\n            }\n\n            _this.responseType = nativeXMLHttpRequest.responseType || \"\";\n            _this.responseURL = nativeXMLHttpRequest.responseURL || \"\";\n\n            emitEvent(_this, \"load\", new EventPolyfill(\"load\", e));\n            emitEvent(_this, \"loadend\", new EventPolyfill(\"loadend\", e));\n\n            break;\n    }\n\n    emitEvent(_this, \"readystatechange\", new EventPolyfill(\"readystatechange\", e));\n\n    return _this;\n}\n\nfunction XMLHttpRequestPolyfill_onProgress(_this, e) {\n    var event;\n\n    if (!hasNativeProgress) {\n        event = new ProgressEventPolyfill(\"progress\", e);\n\n        event.lengthComputable = false;\n        event.loaded = 1;\n        event.total = 1;\n\n        emitEvent(_this, \"progress\", event);\n\n        return event;\n    }\n}\n\nXMLHttpRequestPolyfillPrototype.abort = function() {\n    emitEvent(this, \"abort\", new EventPolyfill(\"abort\", {}));\n    tryCallFunction(this.__nativeXMLHttpRequest, \"abort\");\n};\n\nXMLHttpRequestPolyfillPrototype.setTimeout = function(ms) {\n    this.timeout = ms;\n    trySetValue(this.__nativeXMLHttpRequest, \"timeout\", ms);\n};\n\nXMLHttpRequestPolyfillPrototype.setWithCredentials = function(value) {\n    value = !!value;\n    this.withCredentials = value;\n    trySetValue(this.__nativeXMLHttpRequest, \"withCredentials\", value);\n};\n\nXMLHttpRequestPolyfillPrototype.getAllResponseHeaders = function() {\n    return tryCallFunction(this.__nativeXMLHttpRequest, \"getAllResponseHeaders\");\n};\n\nXMLHttpRequestPolyfillPrototype.getResponseHeader = function(header) {\n    return tryCallFunction(this.__nativeXMLHttpRequest, \"getResponseHeader\", header);\n};\n\nXMLHttpRequestPolyfillPrototype.open = function(method, url, async, user, password) {\n    if (this.readyState === 0) {\n        this.readyState = 1;\n        return tryCallFunction(this.__nativeXMLHttpRequest, \"open\", method, url, async, user, password);\n    } else {\n        return undefined;\n    }\n};\n\nXMLHttpRequestPolyfillPrototype.overrideMimeType = function(mimetype) {\n    tryCallFunction(this.__nativeXMLHttpRequest, \"overrideMimeType\", mimetype);\n};\n\nXMLHttpRequestPolyfillPrototype.send = function(data) {\n    this.__nativeXMLHttpRequest.responseType = this.responseType;\n    tryCallFunction(this.__nativeXMLHttpRequest, \"send\", data);\n};\n\nXMLHttpRequestPolyfillPrototype.setRequestHeader = function(key, value) {\n    this.__requestHeaders[key] = value;\n    tryCallFunction(this.__nativeXMLHttpRequest, \"setRequestHeader\", key, value);\n};\n\nXMLHttpRequestPolyfillPrototype.getRequestHeader = function(key) {\n    return this.__requestHeaders[key];\n};\n\nXMLHttpRequestPolyfillPrototype.getRequestHeaders = function() {\n    return extend({}, this.__requestHeaders);\n};\n\nXMLHttpRequestPolyfillPrototype.sendAsBinary = function(string) {\n    return this.send(toUint8Array(string));\n};\n","var keys = require(\"@nathanfaucett/keys\");\n\n\nmodule.exports = objectForEach;\n\n\nfunction objectForEach(object, callback) {\n    var objectKeys = keys(object),\n        i = -1,\n        il = objectKeys.length - 1,\n        key;\n\n    while (i++ < il) {\n        key = objectKeys[i];\n\n        if (callback(object[key], key, object) === false) {\n            break;\n        }\n    }\n\n    return object;\n}\n","var isNative = require(\"@nathanfaucett/is_native\"),\n    toString = require(\"@nathanfaucett/to_string\");\n\n\nvar StringPrototype = String.prototype,\n\n    reTrim = /^[\\s\\xA0]+|[\\s\\xA0]+$/g,\n    reTrimLeft = /^[\\s\\xA0]+/g,\n    reTrimRight = /[\\s\\xA0]+$/g,\n\n    baseTrim, baseTrimLeft, baseTrimRight;\n\n\nmodule.exports = trim;\n\n\nif (isNative(StringPrototype.trim)) {\n    baseTrim = function baseTrim(str) {\n        return str.trim();\n    };\n} else {\n    baseTrim = function baseTrim(str) {\n        return str.replace(reTrim, \"\");\n    };\n}\n\nif (isNative(StringPrototype.trimLeft)) {\n    baseTrimLeft = function baseTrimLeft(str) {\n        return str.trimLeft();\n    };\n} else {\n    baseTrimLeft = function baseTrimLeft(str) {\n        return str.replace(reTrimLeft, \"\");\n    };\n}\n\nif (isNative(StringPrototype.trimRight)) {\n    baseTrimRight = function baseTrimRight(str) {\n        return str.trimRight();\n    };\n} else {\n    baseTrimRight = function baseTrimRight(str) {\n        return str.replace(reTrimRight, \"\");\n    };\n}\n\n\nfunction trim(str) {\n    return baseTrim(toString(str));\n}\n\ntrim.left = function trimLeft(str) {\n    return baseTrimLeft(toString(str));\n};\n\ntrim.right = function trimRight(str) {\n    return baseTrimRight(toString(str));\n};\n","module.exports = Response;\n\n\nfunction Response() {\n    this.data = null;\n    this.method = null;\n    this.requestHeaders = null;\n    this.responseHeaders = null;\n    this.statusCode = null;\n    this.url = null;\n}\n","var arrayMap = require(\"@nathanfaucett/array-map\"),\n    capitalizeString = require(\"@nathanfaucett/capitalize_string\");\n\n\nmodule.exports = function camelcaseHeader(str) {\n    return arrayMap(str.toLowerCase().split(\"-\"), capitalizeString).join(\"-\");\n};\n","module.exports = function parseContentType(str) {\n    var index;\n\n    if (str) {\n        if ((index = str.indexOf(\";\")) !== -1) {\n            str = str.substring(0, index);\n        }\n        if ((index = str.indexOf(\",\")) !== -1) {\n            return str.substring(0, index);\n        }\n\n        return str;\n    }\n\n    return \"application/octet-stream\";\n};\n","var isNative = require(\"@nathanfaucett/is_native\"),\n    isLength = require(\"@nathanfaucett/is_length\"),\n    isObject = require(\"@nathanfaucett/is_object\");\n\n\nvar objectToString = Object.prototype.toString,\n    nativeIsArray = Array.isArray,\n    isArray;\n\n\nif (isNative(nativeIsArray)) {\n    isArray = nativeIsArray;\n} else {\n    isArray = function isArray(value) {\n        return (\n            isObject(value) &&\n            isLength(value.length) &&\n            objectToString.call(value) === \"[object Array]\"\n        ) || false;\n    };\n}\n\n\nmodule.exports = isArray;\n","var isNullOrUndefined = require(\"@nathanfaucett/is_null_or_undefined\");\n\n\nmodule.exports = apply;\n\n\nfunction apply(fn, args, thisArg) {\n    if (isNullOrUndefined(thisArg)) {\n        return applyNoThisArg(fn, args);\n    } else {\n        return applyThisArg(fn, args, thisArg);\n    }\n}\n\nfunction applyNoThisArg(fn, args) {\n    switch (args.length) {\n        case 0:\n            return fn();\n        case 1:\n            return fn(args[0]);\n        case 2:\n            return fn(args[0], args[1]);\n        case 3:\n            return fn(args[0], args[1], args[2]);\n        case 4:\n            return fn(args[0], args[1], args[2], args[3]);\n        case 5:\n            return fn(args[0], args[1], args[2], args[3], args[4]);\n        default:\n            return fn.apply(null, args);\n    }\n}\n\nfunction applyThisArg(fn, args, thisArg) {\n    switch (args.length) {\n        case 0:\n            return fn.call(thisArg);\n        case 1:\n            return fn.call(thisArg, args[0]);\n        case 2:\n            return fn.call(thisArg, args[0], args[1]);\n        case 3:\n            return fn.call(thisArg, args[0], args[1], args[2]);\n        case 4:\n            return fn.call(thisArg, args[0], args[1], args[2], args[3]);\n        case 5:\n            return fn.call(thisArg, args[0], args[1], args[2], args[3], args[4]);\n        default:\n            return fn.apply(thisArg, args);\n    }\n}\n","var isNative = require(\"@nathanfaucett/is_native\"),\n    isPrimitive = require(\"@nathanfaucett/is_primitive\"),\n    createStore = require(\"@nathanfaucett/create_store\");\n\n\nvar NativeWeakMap = typeof(WeakMap) !== \"undefined\" ? WeakMap : null,\n    WeakMapPolyfill, WeakMapPolyfillPrototype;\n\n\nif (isNative(NativeWeakMap)) {\n    WeakMapPolyfill = NativeWeakMap;\n    WeakMapPolyfillPrototype = WeakMapPolyfill.prototype;\n} else {\n    WeakMapPolyfill = function WeakMap() {\n        this.__store = createStore();\n    };\n    WeakMapPolyfillPrototype = WeakMapPolyfill.prototype;\n    WeakMapPolyfillPrototype.constructor = WeakMapPolyfill;\n\n    WeakMapPolyfillPrototype.get = function(key) {\n        return this.__store.get(key);\n    };\n\n    WeakMapPolyfillPrototype.set = function(key, value) {\n        if (isPrimitive(key)) {\n            throw new TypeError(\"Invalid value used as key\");\n        } else {\n            this.__store.set(key, value);\n        }\n    };\n\n    WeakMapPolyfillPrototype.has = function(key) {\n        return this.__store.has(key);\n    };\n\n    WeakMapPolyfillPrototype[\"delete\"] = function(key) {\n        return this.__store.remove(key);\n    };\n\n    WeakMapPolyfillPrototype.length = 0;\n}\n\nWeakMapPolyfillPrototype.remove = WeakMapPolyfillPrototype[\"delete\"];\n\n\nmodule.exports = WeakMapPolyfill;\n","var apply = require(\"@nathanfaucett/apply\"),\n    isFunction = require(\"@nathanfaucett/is_function\"),\n    isUndefined = require(\"@nathanfaucett/is_undefined\");\n\n\nvar KEYS = 0,\n    VALUES = 1,\n    ENTRIES = 2,\n\n    ITERATOR_SYMBOL = typeof(Symbol) === \"function\" ? Symbol.iterator : false,\n    EMPTY = new Iterator(createDone),\n\n    IteratorPrototype;\n\n\nmodule.exports = Iterator;\n\n\nfunction Iterator(next) {\n    this.next = next;\n}\nIteratorPrototype = Iterator.prototype;\n\nIterator.EMPTY = EMPTY;\n\nfunction IteratorValue(value, done) {\n    this.value = value;\n    this.done = done;\n}\nIterator.Value = IteratorValue;\n\nfunction createValue(type, key, value, result) {\n    var iteratorValue = (\n        type === KEYS ? key :\n        type === VALUES ? value : [key, value]\n    );\n\n    if (isUndefined(result)) {\n        result = new IteratorValue(iteratorValue, false);\n    } else {\n        result.value = iteratorValue;\n    }\n\n    return result;\n}\nIterator.createValue = createValue;\n\nfunction createDone() {\n    return new IteratorValue(undefined, true);\n}\nIterator.createDone = createDone;\n\nfunction getIterator(iterable) {\n    var iteratorFn = iterable && (ITERATOR_SYMBOL && iterable[ITERATOR_SYMBOL] || iterable.iterator);\n\n    if (isFunction(iteratorFn)) {\n        return iteratorFn;\n    } else {\n        return void(0);\n    }\n}\nIterator.getIterator = function(iterable) {\n    var iteratorFn = getIterator(iterable);\n\n    if (iteratorFn) {\n        return function fn() {\n            return apply(iteratorFn, arguments, iterable);\n        };\n    } else {\n        return void(0);\n    }\n};\n\nfunction hasIterator(iterable) {\n    return !!getIterator(iterable);\n}\nIterator.hasIterator = hasIterator;\n\nfunction isIterator(iterator) {\n    return !!(iterator && isFunction(iterator.next));\n}\nIterator.isIterator = isIterator;\n\nIterator.KEYS = KEYS;\nIterator.VALUES = VALUES;\nIterator.ENTRIES = ENTRIES;\n\nIteratorPrototype.toString = function() {\n    return \"[Iterator]\";\n};\nIteratorPrototype.inspect = IteratorPrototype.toSource = IteratorPrototype.toString;\n\nIteratorPrototype.iterator = function() {\n    return this;\n};\nIteratorPrototype[ITERATOR_SYMBOL] = IteratorPrototype.iterator;\n","var has = require(\"@nathanfaucett/has\"),\n    defineProperty = require(\"@nathanfaucett/define_property\"),\n    isPrimitive = require(\"@nathanfaucett/is_primitive\");\n\n\nvar emptyStore = {\n        value: undefined\n    },\n    ObjectPrototype = Object.prototype;\n\n\nmodule.exports = createStore;\n\n\nfunction createStore() {\n    var privateKey = {},\n        size = 0;\n\n\n    function get(key) {\n        var store;\n\n        if (isPrimitive(key)) {\n            throw new TypeError(\"Invalid value used as key\");\n        } else {\n            store = key.valueOf(privateKey);\n\n            if (!store || store.identity !== privateKey) {\n                store = emptyStore;\n            }\n\n            return store;\n        }\n    }\n\n    function set(key) {\n        var store;\n\n        if (isPrimitive(key)) {\n            throw new TypeError(\"Invalid value used as key\");\n        } else {\n            store = key.valueOf(privateKey);\n\n            if (!store || store.identity !== privateKey) {\n                store = privateStore(key, privateKey);\n                size += 1;\n            }\n\n            return store;\n        }\n    }\n\n    return {\n        get: function(key) {\n            return get(key).value;\n        },\n        set: function(key, value) {\n            set(key).value = value;\n        },\n        has: function(key) {\n            var store = get(key);\n            return store !== emptyStore ? has(store, \"value\") : false;\n        },\n        remove: function(key) {\n            var store = get(key);\n\n            if (store !== emptyStore) {\n                size -= 1;\n                return store.remove();\n            } else {\n                return false;\n            }\n        },\n        clear: function() {\n            privateKey = {};\n            size = 0;\n        },\n        size: function() {\n            return size;\n        }\n    };\n}\n\nfunction privateStore(key, privateKey) {\n    var keyValueOf = key.valueOf || ObjectPrototype.valueOf,\n        store = {\n            identity: privateKey,\n            remove: function remove() {\n                if (key.valueOf === valueOf) {\n                    key.valueOf = keyValueOf;\n                }\n                return delete store.value;\n            }\n        };\n\n    function valueOf(value) {\n        if (value !== privateKey) {\n            return keyValueOf.apply(this, arguments);\n        } else {\n            return store;\n        }\n    }\n\n    defineProperty(key, \"valueOf\", {\n        value: valueOf,\n        configurable: true,\n        enumerable: false,\n        writable: true\n    });\n\n    return store;\n}\n","var isObject = require(\"@nathanfaucett/is_object\"),\n    isFunction = require(\"@nathanfaucett/is_function\"),\n    isPrimitive = require(\"@nathanfaucett/is_primitive\"),\n    isNative = require(\"@nathanfaucett/is_native\"),\n    has = require(\"@nathanfaucett/has\");\n\n\nvar nativeDefineProperty = Object.defineProperty;\n\n\nmodule.exports = defineProperty;\n\n\nfunction defineProperty(object, name, descriptor) {\n    if (isPrimitive(descriptor) || isFunction(descriptor)) {\n        descriptor = {\n            value: descriptor\n        };\n    }\n    return nativeDefineProperty(object, name, descriptor);\n}\n\ndefineProperty.hasGettersSetters = true;\n\nif (!isNative(nativeDefineProperty) || !(function() {\n        var object = {},\n            value = {};\n\n        try {\n            nativeDefineProperty(object, \"key\", {\n                value: value\n            });\n            if (has(object, \"key\") && object.key === value) {\n                return true;\n            } else {\n                return false;\n            }\n        } catch (e) {}\n\n        return false;\n    }())) {\n\n    defineProperty.hasGettersSetters = false;\n\n    nativeDefineProperty = function defineProperty(object, name, descriptor) {\n        if (!isObject(object)) {\n            throw new TypeError(\"defineProperty(object, name, descriptor) called on non-object\");\n        }\n        if (has(descriptor, \"get\") || has(descriptor, \"set\")) {\n            throw new TypeError(\"defineProperty(object, name, descriptor) this environment does not support getters or setters\");\n        }\n        object[name] = descriptor.value;\n    };\n}\n","var tryCallFunction = require(\"./tryCallFunction\");\n\n\nvar EventPolyfillPrototype;\n\n\nmodule.exports = EventPolyfill;\n\n\nfunction EventPolyfill(type, nativeEvent) {\n\n    this.__nativeEvent = nativeEvent;\n\n    this.type = type;\n    this.bubbles = nativeEvent.bubbles;\n    this.cancelBubble = nativeEvent.cancelBubble;\n    this.cancelable = nativeEvent.cancelable;\n    this.currentTarget = nativeEvent.currentTarget;\n    this.defaultPrevented = nativeEvent.defaultPrevented;\n    this.eventPhase = nativeEvent.eventPhase;\n    this.isTrusted = nativeEvent.isTrusted;\n    this.path = nativeEvent.path;\n    this.returnValue = nativeEvent.returnValue;\n    this.srcElement = nativeEvent.srcElement;\n    this.target = nativeEvent.target;\n    this.timeStamp = nativeEvent.timeStamp;\n}\nEventPolyfillPrototype = EventPolyfill.prototype;\n\nEventPolyfillPrototype.AT_TARGET = 2;\nEventPolyfillPrototype.BLUR = 8192;\nEventPolyfillPrototype.BUBBLING_PHASE = 3;\nEventPolyfillPrototype.CAPTURING_PHASE = 1;\nEventPolyfillPrototype.CHANGE = 32768;\nEventPolyfillPrototype.CLICK = 64;\nEventPolyfillPrototype.DBLCLICK = 128;\nEventPolyfillPrototype.DRAGDROP = 2048;\nEventPolyfillPrototype.FOCUS = 4096;\nEventPolyfillPrototype.KEYDOWN = 256;\nEventPolyfillPrototype.KEYPRESS = 1024;\nEventPolyfillPrototype.KEYUP = 512;\nEventPolyfillPrototype.MOUSEDOWN = 1;\nEventPolyfillPrototype.MOUSEDRAG = 32;\nEventPolyfillPrototype.MOUSEMOVE = 16;\nEventPolyfillPrototype.MOUSEOUT = 8;\nEventPolyfillPrototype.MOUSEOVER = 4;\nEventPolyfillPrototype.MOUSEUP = 2;\nEventPolyfillPrototype.NONE = 0;\nEventPolyfillPrototype.SELECT = 16384;\n\nEventPolyfillPrototype.preventDefault = function() {\n    return tryCallFunction(this.__nativeEvent, \"preventDefault\");\n};\n\nEventPolyfillPrototype.stopImmediatePropagation = function() {\n    return tryCallFunction(this.__nativeEvent, \"stopImmediatePropagation\");\n};\n\nEventPolyfillPrototype.stopPropagation = function() {\n    return tryCallFunction(this.__nativeEvent, \"stopPropagation\");\n};\n","var inherits = require(\"@nathanfaucett/inherits\"),\n    EventPolyfill = require(\"./EventPolyfill\");\n\n\nmodule.exports = ProgressEventPolyfill;\n\n\nfunction ProgressEventPolyfill(type, nativeEvent) {\n\n    EventPolyfill.call(this, type, nativeEvent);\n\n    this.lengthComputable = nativeEvent.lengthComputable;\n    this.loaded = nativeEvent.loaded;\n    this.total = nativeEvent.total;\n}\ninherits(ProgressEventPolyfill, EventPolyfill);\n","module.exports = tryCallFunction;\n\n\nfunction tryCallFunction(object, name, a0, a1, a2, a3, a4) {\n    try {\n        return object[name](a0, a1, a2, a3, a4);\n    } catch (e) {}\n}\n","module.exports = trySetValue;\n\n\nfunction trySetValue(object, name, key, value) {\n    try {\n        return (object[name][key] = value);\n    } catch (e) {}\n}\n","module.exports = emitEvent;\n\n\nfunction emitEvent(object, type, event) {\n    var onevent = \"on\" + type;\n\n    if (object[onevent]) {\n        object[onevent](event);\n    }\n\n    object.emitArg(type, event);\n}\n","var environment = require(\"@nathanfaucett/environment\");\n\n\nvar Uint8Array = environment.window.Uint8Array || Array;\n\n\nmodule.exports = toUint8Array;\n\n\nfunction toUint8Array(string) {\n    var length = string.length,\n        ui8 = new Uint8Array(length),\n        i = -1,\n        il = length - 1;\n\n    while (i++ < il) {\n        ui8[i] = string.charCodeAt(i) & 0xff;\n    }\n\n    return ui8;\n}\n","var environment = require(\"@nathanfaucett/environment\");\n\n\nvar window = environment.window,\n    NativeXMLHttpRequest = window.XMLHttpRequest,\n\n    createNativeXMLHttpRequest, NativeActiveXObjectType;\n\n\nif (NativeXMLHttpRequest) {\n    createNativeXMLHttpRequest = function createNativeXMLHttpRequest(options) {\n        return new NativeXMLHttpRequest(options);\n    };\n} else {\n    (function getNativeActiveXObject(types) {\n        var NativeActiveXObject = window.ActiveXObject,\n            i = -1,\n            il = types.length - 1,\n            instance, type;\n\n        while (i++ < il) {\n            try {\n                type = types[i];\n                instance = new NativeActiveXObject(type);\n                break;\n            } catch (e) {}\n            type = null;\n        }\n\n        if (!type) {\n            throw new Error(\"XMLHttpRequest not supported by this browser\");\n        }\n\n        NativeActiveXObjectType = type;\n    }([\n        \"Msxml2.XMLHTTP\",\n        \"Msxml3.XMLHTTP\",\n        \"Microsoft.XMLHTTP\"\n    ]));\n\n    createNativeXMLHttpRequest = function createNativeXMLHttpRequest() {\n        return new NativeActiveXObject(NativeActiveXObjectType);\n    };\n}\n\n\nmodule.exports = createNativeXMLHttpRequest;\n","var environment = exports,\n\n    hasWindow = typeof(window) !== \"undefined\",\n    userAgent = hasWindow ? window.navigator.userAgent : \"\";\n\n\nenvironment.worker = typeof(importScripts) !== \"undefined\";\n\nenvironment.browser = environment.worker || !!(\n    hasWindow &&\n    typeof(navigator) !== \"undefined\" &&\n    window.document\n);\n\nenvironment.node = (!hasWindow &&\n    typeof(process) !== \"undefined\" &&\n    typeof(process.versions) !== \"undefined\" &&\n    typeof(process.versions.node) !== \"undefined\" &&\n    typeof(Buffer) !== \"undefined\"\n);\n\nenvironment.mobile = environment.browser && /android|webos|iphone|ipad|ipod|blackberry|iemobile|opera mini/i.test(userAgent.toLowerCase());\n\nenvironment.window = (\n    hasWindow ? window :\n    typeof(global) !== \"undefined\" ? global :\n    typeof(self) !== \"undefined\" ? self : {}\n);\n\nenvironment.pixelRatio = environment.window.devicePixelRatio || 1;\n\nenvironment.document = typeof(document) !== \"undefined\" ? document : {};\n","module.exports = arrayMap;\n\n\nfunction arrayMap(array, callback) {\n    var length = array.length,\n        i = -1,\n        il = length - 1,\n        results = new Array(length);\n\n    while (i++ < il) {\n        results[i] = callback(array[i], i, array);\n    }\n\n    return results;\n}\n","module.exports = capitalizeString;\n\n\nfunction capitalizeString(string) {\n    return string.charAt(0).toUpperCase() + string.slice(1);\n}\n"]}